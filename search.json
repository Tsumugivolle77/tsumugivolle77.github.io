[{"title":"A Proof of an Interesting Property of Normal Matrices","path":"/2024/10/30/A-Proof-of-an-Interesting-Property-of-Normal-Matrices/","content":"I don’t want to waste time to do formula editting so post image instead ;p Description Solution CommentsThe proof consists of 3 important parts: A normal matrix, with property , is diagonalizable by unitary matrix , with , as ; The column vectors of unitary matrix form a set of orthonormal basis of . As a result arbitrary vector can be reformulated as ; The property to be proven is easily shown when the normal matrix is also a diagonal matrix (As is shown in the Lemma).","tags":["maths","linear algebra"]},{"title":"SFINAE 的发展史","path":"/2024/10/25/SFINAE 的发展史/","content":"本文写于2021年12月，发表在本人的老博客和校科协的网站上；现转载于此。 前言说到 C++ 的模板技术，有一个术语不得不提：SFINAE (读作 Sfee-nay，Substitution Failure is Not An Error )。这个技术使得 C++ 这样的静态语言在一定程度上可以实现类似反射的功能 (可以根据类型的特征，表现出不同的行为)。在 C++20 标准概念库发布之后，许多运用到 SFINAE 的场景都可以被概念取代，这一古老的方案也许也将退出到幕后。 当然，这不是一件值得悲伤的事情，这说明标准委员会在积极地寻求摆脱历史的包袱的途径。 这篇文章旨在向想要了解 SFINAE 的读者介绍这一技术的发展历史。 什么是 SFINAE?任何人，看到那样一长串的英文解释，或许都会懵逼。替换失败不是一个错误？什么鬼？ 更加具体地说，这句话的意思是，在模板实例化的过程中，替换失败不是一个错误。 C++98 的做法下面我将以判断一个类是否拥有 size_t size() 方法为例，来深入 SFINAE。 我们希望，假如这个类拥有 size 方法，那么就调用这个方法，否则使用另外一个泛化版本的方法。 traits我们定义一个结构体 hasSize 作为类的特征，假如这个类拥有 size 方法，那么 hasSize::value 将会是 true (或1)，否则为 false。 1234567template &lt;typename T&gt;struct hasSize&#123; // Compile-time Boolean typedef char yes; typedef int no;&#125;; Q: 你一定注意到了上面的 typedef，并且对此有些不解。它是做什么的？ A: 它是用来做编译期的对错判断的。 Q: 为什么要这么写？直接用函数返回 true 或 false 难道不好吗？ A: 确实好，但是 C++98 的函数返回值只能在运行时获得。直到 C++11 引入 constexpr 之后，这一问题才得到改善。 Q: 那为什么这么写就能达成我们的目的？ A: 我们应该还记得 C 里的一个运算符，它长得有点像函数，但与它有关的求值却全都发生在编译期。那就是 sizeof。 12const int a = sizeof(int);const bool b = sizeof(int) == sizeof(char); 上面的两个赋值语句，其赋值号右边的值均可以在编译期求得。而看到第二个语句，你一定已经恍然大悟。 下面就是我们的 SFINAE 登场的时候了。 我们在结构体内加入另外一个脚手架结构体 reallyHas： 1template &lt;typename U, U u&gt; struct reallyHas; 我们在参数 U 中可以给出函数指针的类型，在参数 u 中给出成员函数的具体名字。 然后给出两个函数 test 的重载版本： 123456template &lt;typename U, typename = reallyHas&lt;size_t(U::*)() const, &amp;U::size&gt;&gt;static yes test(U) &#123; &#125;// Fallback:static no test(...) &#123; &#125; 第一个版本返回 yes，接受 U 类型的变量为参数，模板参数列表里第一个是 U，第二个参数是我们之前的脚手架 reallyHas。 第二个版本接受可变长参数。 匹配 test 版本的过程中，会发生这样的事： test 从参数中推导出 U 的具体类型，代入模板的第一个参数，然后把所有的 U 替换成这个类型。 替换 (Substitution) 完毕，接着编译器会去查找实例化后 test 中和替换后 U 有关的部分（本例中就是 size_t(U::*)() const 类型的 &amp;U::size），假如它们不存在，那么这次替换就宣告失败 (Failure)。但替换失败不是一个错误 (Error)，编译器会接着匹配，直到所有候选名单 (candidates) 的成员都不匹配，才会报错。 随着第一个匹配失败，模板去匹配可变长参数版本的 test。这个版本无论如何一定能匹配成功，而它的返回值类型是 no。 然后我们使用一个枚举常量 value 来接受结果：（C++11 之后便被 constexpr 取代） 1234enum&#123; value = sizeof(test(T())) == sizeof(yes)&#125;; 这一过程，我们并不需要函数具体的返回值，而只是对返回值的类型作操作。这冥冥之中也印证了一句话：C++的模板是编译期的多态，是类型的多态（或者也可以说，类型和值本身可以等价）。 当然上面的并不是最终版本，假如我们的 size 有两种可能的版本： size_t(U::*)() const size_t(U::*)() 那么我们就无法简单使用上面的做法了。 下面提供一种更加简洁的做法： 12345678910111213141516171819template &lt;typename T&gt;struct hasSize&#123; typedef char yes; typedef int no; template &lt;typename U, U u&gt; struct reallyHas; template &lt;typename U&gt; static yes test( reallyHas&lt;size_t(U::*)(), &amp;U::size&gt; *) &#123; &#125; template &lt;typename U&gt; static yes test( reallyHas&lt;size_t(U::*)() const, &amp;U::size&gt; *) &#123; &#125; template &lt;typename&gt; static no test(...) &#123; &#125; enum &#123; value = sizeof(test&lt;T&gt;(int())) == sizeof(yes) &#125;;&#125;; 由于 C++ 整形可以隐式转化为指针，我们仍然会先匹配 yes 版本的 test。 enable_if下面我们使用之前的 hasSize 来帮助我们实现目的。我们来引入另外一个工具人：enable_if。 123456789template &lt;bool, typename T&gt;struct enable_if&#123; typedef T type;&#125;;template &lt;typename T&gt;struct enable_if&lt;false, T&gt;&#123; &#125;; 看起来有点懵？不知道它要干嘛？我们继续实现我们的 getSize 函数： 12345678910111213141516template &lt;typename T&gt; typename enable_if&lt;hasSize&lt;T&gt;::value, size_t&gt;::typegetSize(const T &amp;obj)&#123; std::cout &lt;&lt; &quot;obj has size&quot; &lt;&lt; std::endl; return obj.size();&#125;template &lt;typename T&gt;/* disable if: */ typename enable_if&lt;!hasSize&lt;T&gt;::value, size_t&gt;::typegetSize(const T &amp;obj)&#123; std::cout &lt;&lt; &quot;obj has no size&quot; &lt;&lt; std::endl; return sizeof(obj);&#125; 两处都得写上 enable_if，否则会产生二义性。（如果其中一个 enable_if 的参数1为 true，那么返回值类型是 size_t，那么另外一个 enable_if 必然没有返回值类型（也就是type成员），所以它会被排除在候选名单之外，假如另外一个函数拥有返回值类型，那么这个时候编译器将会不明白应该调用哪个版本的函数，从而产生 error） 下面来试验一下： 1234std::vector&lt;int&gt; v = &#123;4, 5, 6, 7&#125;;char c = &#x27;c&#x27;;std::cout &lt;&lt; getSize(v) &lt;&lt; std::endl;std::cout &lt;&lt; getSize(c) &lt;&lt; std::endl; 输出结果： 1234obj has size4obj has no size1 时间来到 C++11我们在讲述 C++98 的解决方法的时候，已经说过：许多东西到了 C++11 会有更好的解决办法。 现在我们终于可以介绍 C++11 了。 其实本来并没有 C++11，它最早的名字叫做 C++0x，因为人们坚信在二十一世纪的前十年 C++11 的标准就能够实现，然而实际上直到2011年，C++11 才正式发布。 C++11 为模板编程带来了许多的便利。 首先是编译期表达式类型推导 decltype。 接着是 std::declval，这是一个模板函数，它允许我们构造一个类型 T 的临时量，而无需我们提供参数对其构造。 还有我们之前说过的 constexpr，也是千呼万唤始出来。 std::enable_if，它进标准了。 当然还有新的标准库头文件，type_traits，它为我们提供了许许多多方便的 traits，我们不需要再自己手动实现了。 在 C++11 中，我们将使用另外一个例子——判断一个类是否是可以比较大小的。(这里以小于号为例) 我们写一个类模板 isComparable： 12345678910111213template &lt;typename T&gt;struct isComparable&#123; template &lt;typename U&gt; static constexpr bool test( decltype(std::declval&lt;U&gt;() &lt; std::declval&lt;U&gt;()) *) &#123; return true; &#125; template &lt;typename&gt; static constexpr bool test(...) &#123; return false; &#125;\t// C++11 initializer list static constexpr bool value &#123; test&lt;T&gt;(int()) &#125;;&#125;; 在 test 的参数中用到了 decltype 和 std::declval。用 declval 来查询是否两个 U 类型的变量重载了（或者本身就拥有）operator&lt;，如果拥有，则匹配成功，否则匹配失败，将会匹配可变长参数版本的 test。 C++11 版本下我们的许多操作变得更加符合直觉，实现也更加简洁明了。 试验： 1234567891011class Test1&#123;public: bool operator&lt;(Test1);&#125;;class Test2&#123; &#125;;std::cout &lt;&lt; isComparable&lt;Test1&gt;::value &lt;&lt; std::endl; // 1std::cout &lt;&lt; isComparable&lt;Test2&gt;::value &lt;&lt; std::endl; // 0 除此之外还有另一种方法： 1234567891011template &lt;typename T, typename = bool&gt;struct isComparable: std::false_type// 继承而来的 value 成员为 false，下面类似。&#123; &#125;;template &lt;typename T&gt;struct isComparable&lt; T, decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;: std::true_type&#123; &#125;; 第一个版本的 isComparable 默认参数一定要设为 bool，也就是 operator&lt; 返回值的类型，原因是： 当类模板有默认参数的时候，编译器会更加偏袒那个有默认参数的模板； 当带有默认参数的模板与另外一个偏特化模板参数一致的时候，则会优先选择那个偏特化的版本。 于是当 [T = Test1]，偏特化版本模板的第二个参数也是 bool，于是选择了第二个偏特化版本的模板。 当 [T = Test2]，SFINAE 的规则让我们不得不选择第一个版本的模板。 C++14 泛型 lambdaC++14 让我们的匿名函数支持 auto 类型的参数。它的本质其实就是带有模板括号运算符的仿函数。 12345678auto f = [] (auto x) &#123; return x; &#125;;// equivalent to:struct Unnamed&#123; template &lt;typename T&gt; auto operator()(T x) &#123; return x; &#125;&#125; functor; 因此 SFINAE 的技术也能够适用于它。 我们可以用泛型 lambda 来实现袖珍版的 traits。 先上效果： 1234567891011121314151617181920class A &#123; &#125;;class B&#123;public: bool operator&lt;(B const &amp;) const &#123; &#125;&#125;;auto hasLess = is_valid([] (auto &amp;&amp;x) -&gt; decltype(x &lt; x) &#123; &#125;);std::cout &lt;&lt; std::boolalpha;std::cout &lt;&lt; hasLess(43) &lt;&lt; std::endl;std::cout &lt;&lt; hasLess(A()) &lt;&lt; std::endl;std::cout &lt;&lt; hasLess(B()) &lt;&lt; std::endl;auto comparableWith = is_valid( [] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;);std::cout &lt;&lt; comparableWith(43, &quot;Abc&quot;s) &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(43, 72.2) &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(B(), B()) &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(A(), B()) &lt;&lt; std::endl; 输出结果： 1234567truefalsetruefalsetruetruefalse 这个 is_valid 是个啥，好神奇。下面我们就来详细解释一下： 首先，它是一个工厂函数。产生 is_valid_impl 类型的对象。 1234567891011121314151617181920212223242526template &lt;typename F&gt;struct is_valid_impl&#123;private: F _f; template &lt;typename... Ts&gt; static constexpr auto test(Ts&amp;&amp;... ts) -&gt; decltype(_f(ts...), true) &#123; return true; &#125; // fallback static constexpr bool test(...) &#123; return false; &#125;public: constexpr explicit is_valid_impl(F &amp;&amp;f): _f(f) &#123; &#125; template &lt;typename... Us&gt; constexpr auto operator()(Us&amp;&amp;... us) &#123; return test(us...); &#125;&#125;;template &lt;typename F&gt;is_valid_impl&lt;F&gt; is_valid(F &amp;&amp;f)&#123; return is_valid_impl&lt;F&gt;(std::forward&lt;F&gt;(f)); &#125; is_valid_impl 的工作原理： 依靠 is_valid_impl 构造函数把仿函数对象 _f 初始化。 operator() 从调用时的实参列表推导出来 Us... 将运算委任给 test 函数。 首先匹配第一个版本的 test，这个过程有 SFINAE 的参与：decltype 时，将形参代入 _f，而我们的 _f 形如：[] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;，如果参数无法进行某些指定操作，或者参数长度不匹配，那么第一个版本的 test 被 SFINAE out。否则匹配成功，返回 true。 匹配失败，这个时候就进入第二个版本的 test，其无论如何都会返回 false。 由于 C++14 参数推导还不够智能，所以我们这里不得不使用一个工厂函数来帮助我们推导 F 的类型，而在后续标准，我们可以不再需要这个工厂函数，而直接使用构造函数了。 C++17 void_tC++17 引入了一个 类模板std::void_t，它可以干啥呢？接受一长串的类型，但自己永远是 void。它其实就是一个别名模板，长成这样： 12template &lt;typename...&gt;using void_t = void; 现在可以方便地使用 decltype + 逗号表达式，来完成一长串的判断，而无需判断返回值类型了（有的时候返回值类型是难以判断的，比如返回值类型带有模板参数）。 下面给出一个终极版 isComparable： 1234567891011121314template &lt;typename T, typename = void&gt;struct isComparable: std::false_type&#123; &#125;;template &lt;typename T&gt;struct isComparable&lt;T, std::void_t&lt;decltype( std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;(), std::declval&lt;T&gt;() &gt; std::declval&lt;T&gt;(), std::declval&lt;T&gt;() &gt;= std::declval&lt;T&gt;(), std::declval&lt;T&gt;() &lt;= std::declval&lt;T&gt;(), std::declval&lt;T&gt;() == std::declval&lt;T&gt;(), std::declval&lt;T&gt;() != std::declval&lt;T&gt;())&gt;&gt;: std::true_type&#123; &#125;; C++20 concepts如前言所说，C++20 概念库或给 SFINAE 的时代画上一个句号。那么我们也用概念重写的 isComparable 为本文画上一个句号。 1234567891011121314template &lt;typename T&gt;concept is_bool = std::is_convertible_v&lt;T, bool&gt;;template &lt;typename T&gt;concept isComparable = requires (T t)&#123; &#123;t &gt; t&#125; -&gt; is_bool; &#123;t &lt; t&#125; -&gt; is_bool; &#123;t &gt;= t&#125; -&gt; is_bool; &#123;t &lt;= t&#125; -&gt; is_bool; &#123;t == t&#125; -&gt; is_bool; &#123;t != t&#125; -&gt; is_bool;&#125;;template &lt;typename T&gt;concept isNotComparable = !isComparable&lt;T&gt;; 我们可以这么使用： 123456789101112131415// 使用不同的概念我们可以提供不同的重载函数版本（即便参数列表相同）void foo(isComparable auto&amp;&amp;)&#123; std::cout &lt;&lt; &quot;is comparable&quot; &lt;&lt; std::endl;&#125;void foo(isNotComparable auto&amp;&amp;)&#123; std::cout &lt;&lt; &quot;is not comparable&quot; &lt;&lt; std::endl;&#125;class Test &#123; &#125;;foo(1);foo(Test()); 结果： 12is comparableis not comparable 当然我们可以把 concepts 和上面的那些类模板结合起来，用来做空基类优化，不过那就不是本文要讨论的内容了。 后记尽管我曾在前言说过，我们毋须为 SFINAE 技术的退出而悲伤，但我认为 SFINAE 技术是老一代 C++ 工程师智慧的结晶。二十多年过去，C++ 标准从跛脚逐步开始走向完善，使用 C++ 抽象的方法日趋成熟，我想这其中不无他们的功劳。在模板技术发展的过程中，许多东西都事出偶然，然而如果没有前人的不懈尝试，这些偶然又怎会成为已经发生的必然？ 当然，SFINAE 作为 C++ 本身的一个语言规则，它仍然会在底层发挥作用。不得不直接倚赖底层的东西去解决上层的问题，这是 C++ 过去的缺陷。 人们始终不停地在探索这个语言的极限，我想这才是 C++ 吸引人的地方。 如果这篇文章能给读者带来一丝启发，那就再好不过了。 参考Jean Guegant: An introduction to C++’s SFINAE concept: compile-time introspection of a class member [https://jguegant.github.io/blogs/tech/sfinae-introduction.html] （我的 SFINAE 启蒙读物）","tags":["C++","SFINAE","templates"]},{"title":"鸟白岛巡礼指北","path":"/2024/10/25/鸟白岛巡礼指北/","content":"本文搬运自本人的b站专栏。 写在前面今天是2024年7月26日。本人刚刚从日本返回中国，总计在日本停留了九天，其中前三天在高松（包括男木岛、女木岛、直岛）度过。决定写一篇专栏来记录我的第一次巡礼之旅。这是一场身体很累，但心灵却得到治愈的旅途。在这之中，我收获了许多意外的惊喜。 由于秋叶原Cafe&amp;Bar MENU咖啡吧的Summer Pockets联动（原先定于7月25日结束，现已延迟到9月1日结束，需要提前预约），在高松旅程结束之后，笔者一路北上经由： “高松 –轮渡–&gt; 直岛 –轮渡–&gt; 宇野 –JR+新干线–&gt; 大阪 –阪急–&gt; 京都 –JR（原定新干线，但当天新干线脱轨。不是万不得已请不要使用JR，会绕很远的路且费用更高）–&gt; 东京”的线路最终到达秋叶原（途中当然在各地都进行了游玩）。 此外，如果不打算前往京都，飞机也是一个很好的选择（京都没有任何的公共机场，如果你长了螺旋桨，那么忽视这一段）。如果没有鸟白岛巡礼以外的其他目的，那么全程几乎不需要用到JR或是新干线等轨道交通（在这种情况下，也没有必要购买交通卡）。 接下来，本文将会囊括以下内容： Part 1. 住宿的选项 1.1 住在高松或直岛 1.2 住在男木岛 1.3 住在女木岛 Part 2. 乘坐渡轮的细节 2.1 雌雄岛航线 2.2 四国航线 Part 3. 巡礼线路选择、岛上的交通方式 3.1 巡礼线路选择 3.2 岛上交通方式 Part 4. 可能会错过的一些巡礼地点 Part 5. 季节性的活动（2024年） Part 6. 巡礼可以选择的（软件）工具 Part 7. 在不会日语的情况下，你可以做什么准备工作 结语 本文中的内容并不一定是我的亲身经历，有一部分来自于问询其他巡礼者，仅在本文中将其记录，以备今后二周目巡礼时查看。如果这篇文章可以在未来的某个时间帮到某个人，那么就再好不过了。 Part 1. 住宿的选项1.1 住在高松或直岛高松或直岛本身旅游开发比较完善，因此你可以使用住宿软件十分轻松地订到这两处的酒店。如果你选择住在高松，那么请注意选择邻近高松港的酒店。假如你打算居住在游戏中的加藤家（现实中位于直岛的石井商店），那么请提前大约4个月预订（消息来源：我在巡礼过程中，在石井商店遇到的一位中国SP粉丝）。 1.2 住在男木岛如果你是一个紬厨，希望拍摄到黄昏或夜晚的灯塔；或者渴望体验游戏中羽依里、細、静久三人合宿的剧情，那么住宿在男木岛是一个不错的选择。我并没有居住在男木岛，在巡礼回来之前也并不知晓男木岛住宿的方法，直到我询问了一位在男木岛过夜的中国SP粉丝，得到的答案如下：岛上的旅店；灯塔露营；住丰爷家。男木岛上的旅店目前暂且无法通过线上方式进行预订，需要线下自行沟通。而关于丰爷，我会在后文介绍。可以预料到，住在男木岛对于初次巡礼的人（尤其是社恐二次元）很难实行，也具有很大的不确定性。 1.3 住在女木岛嗯？谁会住在女木岛。 Part 2. 乘坐渡轮的细节前往男木岛和女木岛以及前往直岛的航线分别由：雌雄岛海运株式会社以及四国海运株式会社运营。二者的售票处位于相距几百米的不同地点，如果不知道具体位置，可以用日语或简单的英语询问工作人员。对于各交通节点之间的可达关系，可以这样概括：高松港、男木岛和女木岛之间两两可达，高松港、宇野和直岛之间两两可达。 2.1 雌雄岛航线由于男木岛和女木岛属于较冷门的旅游景点，每天的渡轮班次相对较少，而且每天很早就结束运营。其海运时间表如下图所示：注意：发船时刻提前半个小时开始售票。从图中可以得知，如果选择在8月的前20天出行，则班次会相对较多，行程安排会更加自由。 2.2 四国航线直岛往返的渡轮时刻表，如下图绿色部分所示（红色部分是岛上大巴、蓝色部分是直岛艺术馆的免费巴士):上图为前往直岛、下图为离开直岛。 Part 3. 巡礼线路选择、岛上的交通方式3.1 巡礼线路选择巡礼的顺序大概可以分成以下四类： 男木女木、直岛； 直岛、男木女木； 女木男木、直岛； 直岛、女木男木。首先，个人而言，我并不推荐将女木岛放在男木岛前面，尽管它距离高松港最近。我更加推荐以直岛或男木岛作为巡礼的起点。这两者之间，我会更加优先参观男木岛。对于初次巡礼的时间安排上，我的建议是两到三天。在直岛上完全可以待上两天时间，去享受夏季的阳光沙滩，或者参观一下岛上的艺术馆，感受“度过快乐暑假的秘诀”。如无特殊情况（例如准备在男木岛过夜），男木岛和女木岛一天足矣。接下来，介绍一下优先男木岛的理由。这里就不得不提到之前所说的丰爷（twitter id:@nekopoketoyoji)。除去已经关门的直岛小卖铺，男木岛丰爷的ねこポケハウス（NekopokeHouse）是三座岛上Summer Pockets元素最为浓厚的地方。丰爷的家里接待过无数各地的SP厨和爱猫人士，你可以在那找到各种的SP周边、在来访者日记中留下自己的痕迹、和其他到访的SP厨交流心得、得到一些巡礼的指南、或者吸一会猫。丰爷是一个非常有意思的老爷爷，经常在推特上冲浪。很遗憾的是，我前往男木岛的那天，丰爷刚好因为有事前往高松。我只在男木岛役馆（村公所）门口见到他一面，并且没认出来他，我的紬痛T引起了他的注意。后来，我们在推特上也有一些友好的交流。如果有能力的话，完全可以在巡礼之前先在推特上和丰爷提前联系，打个招呼。丰爷的家就在男木岛下船后，右手边役所旁边的小道往里。（小道旁边有一片墓地，可以方便定位。没有恶意） 3.2 岛上交通方式男木岛：有且只有步行，岛上道路坡度比较大，注意安全、记得补充体力。不要打扰到岛上的居民。 女木岛：主要的巡礼地点是鬼岛大洞窟（鸥线），下船后购买巴士票直达。 直岛：租借自行车（宫浦港旁边非常显眼的一家店铺）和公交车（100日元可以坐到岛上任意一站，可以在港口附近的售票处找一本直岛指南（如下图）随手查阅路线和运营时间）。直岛上的交通是最方便的。（如果你重新玩一遍《夏日口袋》的话，会发现羽依里在上岛后不久即遭遇了公交车，这点十分还原） Part 4. 可能会错过的一些巡礼地点游戏标题画面的出处在直岛地中艺术馆可以找到。不太好找，也不太像。是日本友人带我找到的。 白羽线吃可丽饼的cg在JR宇野站的停车场内（我当时并没有想起来去找）。 迷途橘的原型在国营常陆海滨公园（从东京使用公共交通过去得4个小时以上），建议4、5月份花期的时候去。这里我还闹了一个乌龙，找到另一个名字很像的地方了，不过当时时间也很紧，就没再找下去了。如果打算去，建议在附近住宿并且安排一天的时间。图片来自谷歌地图。 直岛上，加藤家&#x2F;岛上食堂原型的石井商店营业时间是11点到下午2点，如要就餐记得妥善安排时间。 紬家的原型起云阁：4-2 Showacho, Atami, Shizuoka 413-0022日本。 鸥线海盗船停靠的地点原型龙宫窟：Touji, Shimoda, Shizuoka 415-0029日本。 Part 5. 季节性的活动（2024年）Summer Pockets的许多活动的开始&#x2F;结束都与7月25日有关，游戏中这一天是羽依里上岛的日子。如果你提前几个月在做圣地巡礼的计划（例如希望以此作为毕业旅行），那么建议将旅行的时间定在这一天之后。更具体一点：这一天之后的周末、或是8月31日（紬的生日）。如果这样计划，碰上特别的活动的概率会最大化。例如，2024年7月25日之后的第一个周六，也就是7月27日，是Key社Summer Festival售卖SP周边开始的时间。同样是这一年，7月25日开始到8月31日结束，是男木岛灯台祭的期间，起的早一些有可能遇上意外之喜；如果更特殊一点，碰上了这一段时间的周末，那么也许就有机会进到灯塔内部参观。当然也有例外，秋叶原的SP咖啡厅联动原定于7月25日截止（现在延迟到9月1日）。关于咖啡厅的预约（一般需要提供日本手机号），我通过本人经验和与其他人交流，总结出了以下方法：直接通过推特私信与工作人员联系。这种方法可能不太礼貌，但我成功了；在手机号一栏填写中国驻日大使馆的电话号码；使用咖啡厅的提问网站进行问询和预约，给清楚信息，说 明来意：https://menu-store.com/inquiry；“没必要这么麻烦，我有日本手机号”，那么直接预订即可。联动咖啡厅的部分商品在秋叶原电波会馆的K-Books中被溢价倒卖，本人十分反感这种行为，因为我没在咖啡厅买到我想要的爱丽丝紬徽章。如果实在有想要单收的周边，可以去那看看。 Part 6. 巡礼可以选择的（软件）工具首先，出国在外，我建议你不要使用华为手机。提前买好日本流量卡。带好充电宝，手机开着导航耗电飞快。我所使用到的工具大致如下： Google地图：在日本比较好用的地图工具； Google翻译：如果你在日语不好的情况下英语又不太好&#x2F;需要和不会使用英语的日本人交流，那么可以使用。提前熟悉功能（例如语音翻译等)，谷歌翻译的质量还是堪忧的； Anitabi动画巡礼网站：https://anitabi.cn/map,可以比较方便地查找到巡礼地点的位置； 换乘案内：一个查询日本换乘路线的APP； Agoda：酒店预订工具，使用别的软件替代也无所谓； 其他（待补充） Part 7. 在不会日语的情况下，你可以做什么准备工作在一个陌生的环境下，你的外表是最具冲击力的语言。如果你想第一时间让别人知道自己的目的，你可以选择穿一件喜欢角色的痛T（如果经济实力不够，淘宝定制的就足够了）。这是本人定制的痛T：这是我的成果：此外，提前在推特上关注丰爷等人的账号，熟悉外面的SP圈子，实时记录行程，可以帮助你更快地找到同好。日本人废话说的不少，提前记一些常用日本礼貌用语，可以给他人留下一个好印象。他们做事的条条框框也比较多，可以提前熟悉，给自己一个比较好的体验。比如说：日本人走路会固定走某一侧，记得留意脚下的方向标志；在自动扶梯上记得空出右边的一条通路给赶时间的人行走；用完餐起身之前说一句「ご馳走樣でした。」表示对厨师的感谢；需要其他人帮忙的时候私密马赛一下绝对没有错。最重要的一点是，注意日本店铺的营业时间：许多（不是全部）店铺10点才开门（石井商店是11点），而晚上6点（比如说直岛上的餐厅）~8点就已经关门了；如果需要吃早餐，可以去随处可见的711、全家福超市（巡礼的体力消耗不小，建议不要忘记吃早餐）。 结语祝愿读到这篇专栏的人能够从中获取一些有用的信息，可以在鸟白岛找到探求之物、找到自己、找到想做的事!","tags":["Summer Pockets","travel"]},{"title":"关于","path":"/about/index.html","content":"This blog will only present those “processed” knowledge, instead of those unconscious hollow copies from textbooks, blog of others etc. 中文&#x2F;English&#x2F;Deutsch. 余暇で日本語を勉強します。 I love Nintendo (Pokémon, Fire Emblem, Zelda etc.)&#x2F;Visual Novel (サマポケ、さくらもゆ..) むぎゅぎゅ~ X&#x2F;Twitter: https://x.com/Offensive771Github: https://github.com/Tsumugivolle77"},{"title":"Link to Me","path":"/explore/index.html","content":"TwitterGithub"},{"title":"友人帳","path":"/links/index.html","content":"GalaxyerKw"},{"title":"Collections","path":"/wiki/index.html","content":"本页会收录个人认为有趣的链接。"}]