<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="Golden Hours" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://tsumugivolle77.github.io/2024/10/25/SFINAE 的发展史/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title> - Golden Hours</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Golden Hours</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Golden Hours</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-25
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SFINAE-%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.</span> <span class="toc-text">SFINAE 的发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SFINAE"><span class="toc-number">1.2.</span> <span class="toc-text">什么是 SFINAE?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-98-%E7%9A%84%E5%81%9A%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">C++98 的做法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#traits"><span class="toc-number">1.3.1.</span> <span class="toc-text">traits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-if"><span class="toc-number">1.3.2.</span> <span class="toc-text">enable_if</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%9D%A5%E5%88%B0-C-11"><span class="toc-number">1.4.</span> <span class="toc-text">时间来到 C++11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-14-%E6%B3%9B%E5%9E%8B-lambda"><span class="toc-number">1.5.</span> <span class="toc-text">C++14 泛型 lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-17-void-t"><span class="toc-number">1.6.</span> <span class="toc-text">C++17 void_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-20-concepts"><span class="toc-number">1.7.</span> <span class="toc-text">C++20 concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">1.8.</span> <span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.9.</span> <span class="toc-text">参考</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <h1 id="SFINAE-的发展史"><a href="#SFINAE-的发展史" class="headerlink" title="SFINAE 的发展史"></a>SFINAE 的发展史</h1><p>本文写于2021年12月，发表在本人的老博客和校科协的网站上；现转载于此。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到 C++ 的模板技术，有一个术语不得不提：<strong>SFINAE</strong> (读作 Sfee-nay，<strong>S</strong>ubstitution <strong>F</strong>ailure is <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror )。这个技术使得 C++ 这样的静态语言在一定程度上可以实现类似反射的功能 (可以根据类型的特征，表现出不同的行为)。在 C++20 标准概念库发布之后，许多运用到 <strong>SFINAE</strong> 技术的场景都可以被概念取代，这一古老的技术也许也将退出历史舞台。</p>
<p>当然，这不是一件值得悲伤的事情，这说明标准委员会在积极地寻求摆脱历史的包袱的途径。</p>
<p>这篇文章旨在向想要了解 <strong>SFINAE</strong> 的读者介绍这一技术的发展历史。</p>
<h2 id="什么是-SFINAE"><a href="#什么是-SFINAE" class="headerlink" title="什么是 SFINAE?"></a>什么是 <strong>SFINAE</strong>?</h2><p>任何人，看到那样一长串的英文解释，或许都会懵逼。<strong>替换失败不是一个错误？</strong>什么鬼？</p>
<p>更加具体地说，这句话的意思是，在<strong>模板实例化的过程中，替换失败不是一个错误。</strong></p>
<h2 id="C-98-的做法"><a href="#C-98-的做法" class="headerlink" title="C++98 的做法"></a>C++98 的做法</h2><p>下面我将以判断一个类是否拥有 <code>size_t size()</code> 方法为例，来深入 <strong>SFINAE</strong>。</p>
<p>我们希望，假如这个类拥有 <code>size</code> 方法，那么就调用这个方法，否则使用另外一个泛化版本的方法。</p>
<h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>我们定义一个结构体 <code>hasSize</code> 作为类的特征，假如这个类拥有 <code>size</code> 方法，那么 <code>hasSize::value</code> 将会是 <code>true </code> (或1)，否则为 <code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasSize</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compile-time Boolean</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>  no;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>Q:</strong> 你一定注意到了上面的 <code>typedef</code>，并且对此有些不解。它是做什么的？</p>
<p><strong>A:</strong> 它是用来做编译期的对错判断的。</p>
<p><strong>Q:</strong> 为什么要这么写？直接用函数返回 <code>true</code> 或 <code>false</code> 难道不好吗？</p>
<p><strong>A:</strong> 确实好，但是 C++98 的函数返回值只能在运行时获得。直到 C++11 引入 <code>constexpr</code> 之后，这一问题才得到改善。</p>
<p><strong>Q:</strong> 那为什么这么写就能达成我们的目的？</p>
<p><strong>A:</strong> 我们应该还记得 C 里的一个运算符，它长得有点像函数，但与它有关的求值却全都发生在编译期。那就是 <code>sizeof</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> b = <span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br></pre></td></tr></table></figure>

<p>上面的两个赋值语句，其赋值号右边的值均可以在编译期求得。而看到第二个语句，你一定已经恍然大悟。</p>
<p>下面就是我们的 <strong>SFINAE</strong> 登场的时候了。</p>
<p>我们在结构体内加入另外一个脚手架结构体 <code>reallyHas</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, U u&gt; <span class="keyword">struct</span> <span class="title class_">reallyHas</span>;</span><br></pre></td></tr></table></figure>

<p>我们在参数 <code>U</code> 中可以给出函数指针的类型，在参数 <code>u</code> 中给出成员函数的具体名字。</p>
<p>然后给出两个函数 <code>test</code> 的重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">          <span class="keyword">typename</span> = reallyHas&lt;<span class="built_in">size_t</span>(U::*)() <span class="type">const</span>, &amp;U::size&gt;&gt;</span><br><span class="line"><span class="type">static</span> yes <span class="built_in">test</span>(U) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback:</span></span><br><span class="line"><span class="type">static</span> no <span class="built_in">test</span>(...) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>第一个版本返回 <code>yes</code>，接受 <code>U</code> 类型的变量为参数，模板参数列表里第一个是 <code>U</code>，第二个参数是我们之前的脚手架 <code>reallyHas</code>。</p>
<p>第二个版本接受可变长参数。</p>
<p>匹配 <code>test</code> 版本的过程中，会发生这样的事：</p>
<ul>
<li><code>test</code> 从参数中推导出 <code>U</code> 的具体类型，代入模板的第一个参数，然后把所有的 <code>U</code> 替换成这个类型。</li>
<li>替换 (Substitution) 完毕，接着编译器会去查找实例化后 <code>test</code> 中和替换后 <code>U</code> 有关的部分（本例中就是 <code>size_t(U::*)() const</code> 类型的 <code>&amp;U::size</code>），假如它们不存在，那么这次替换就宣告失败 (Failure)。但替换失败不是一个错误 (Error)，编译器会接着匹配，直到所有候选名单 (<em>candidates</em>) 的成员都不匹配，才会报错。</li>
<li>随着第一个匹配失败，模板去匹配可变长参数版本的 <code>test</code>。这个版本无论如何一定能匹配成功，而它的返回值类型是 <code>no</code>。</li>
</ul>
<p>然后我们使用一个枚举常量 <code>value</code> 来接受结果：（C++11 之后便被 <code>constexpr</code> 取代）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>(<span class="built_in">T</span>())) == <span class="built_in">sizeof</span>(yes)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这一过程，我们并不需要函数具体的返回值，而只是对返回值的类型作操作。这冥冥之中也印证了一句话：C++的模板是编译期的多态，是类型的多态（或者也可以说，类型和值本身可以等价）。</p>
<p>当然上面的并不是最终版本，假如我们的 <code>size</code> 有两种可能的版本：</p>
<ul>
<li><code>size_t(U::*)() const</code></li>
<li><code>size_t(U::*)()</code></li>
</ul>
<p>那么我们就无法简单使用上面的做法了。</p>
<p>下面提供一种更加简洁的做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasSize</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>  no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, U u&gt; <span class="keyword">struct</span> <span class="title class_">reallyHas</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">static</span> yes <span class="title">test</span><span class="params">(reallyHas&lt;<span class="type">size_t</span>(U::*)(), &amp;U::size&gt; *)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">static</span> yes <span class="title">test</span><span class="params">(reallyHas&lt;<span class="type">size_t</span>(U::*)() <span class="type">const</span>, &amp;U::size&gt; *)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="function"><span class="type">static</span> no <span class="title">test</span><span class="params">(...)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="built_in">int</span>())) == <span class="built_in">sizeof</span>(yes)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 C++ 整形可以隐式转化为指针，我们仍然会先匹配 <code>yes</code> 版本的 <code>test</code>。</p>
<h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><p>下面我们使用之前的 <code>hasSize</code> 来帮助我们实现目的。我们来引入另外一个工具人：<code>enable_if</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">false</span>, T&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>看起来有点懵？不知道它要干嘛？我们继续实现我们的 <code>getSize</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;hasSize&lt;T&gt;::value, <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj has size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">/* disable if: */</span></span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;!hasSize&lt;T&gt;::value, <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj has no size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两处都得写上 <code>enable_if</code>，否则会产生二义性。（如果其中一个 <code>enable_if</code> 的参数1为 <code>true</code>，那么返回值是 <code>size_t</code>，那么另外一个 <code>enable_if</code> 必然没有返回值，所以它会被排除在候选名单之外，假如另外一个函数拥有返回值，那么这个时候编译器将会不清楚应该调用哪个版本的函数，从而产生 error）</p>
<p>下面来试验一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">getSize</span>(v) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">getSize</span>(c) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj has size</span><br><span class="line">4</span><br><span class="line">obj has no size</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="时间来到-C-11"><a href="#时间来到-C-11" class="headerlink" title="时间来到 C++11"></a>时间来到 C++11</h2><p>我们在讲述 C++98 的解决方法的时候，已经说过：许多东西到了 C++11 会有更好的解决办法。</p>
<p>现在我们终于可以介绍 C++11 了。</p>
<p>其实本来并没有 C++11，它最早的名字叫做 C++0x，因为人们坚信在二十一世纪的前十年 C++11 的标准就能够实现，然而实际上直到2011年，C++11 才正式发布。</p>
<p>C++11 为模板编程带来了许多的便利。</p>
<ul>
<li>首先是编译期表达式类型推导 <code>decltype</code>。</li>
<li>接着是 <code>std::declval</code>，这是一个模板函数，它允许我们构造一个类型 <code>T</code> 的临时量，而无需我们提供参数对其构造。</li>
<li>还有我们之前说过的 <code>constexpr</code>，也是千呼万唤始出来。</li>
<li><code>std::enable_if</code>，它进标准了。</li>
<li>当然还有新的标准库头文件，<code>type_traits</code>，它为我们提供了许许多多方便的 <code>traits</code>，我们不需要再自己手动实现了。</li>
</ul>
<p>在 C++11 中，我们将使用另外一个例子——判断一个类是否是可以比较大小的。(这里以小于号为例)</p>
<p>我们写一个类模板 <code>isComparable</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">decltype</span>(std::declval&lt;U&gt;() &lt; std::declval&lt;U&gt;()) *)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(...)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">	<span class="comment">// C++11 initializer list</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value &#123; <span class="built_in">test</span>&lt;T&gt;(<span class="built_in">int</span>()) &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在  <code>test</code> 的参数中用到了 <code>decltype</code> 和 <code>std::declval</code>。用 <code>declval</code> 来查询是否两个 <code>U</code> 类型的变量重载了（或者本身就拥有）<code>operator&lt;</code>，如果拥有，则匹配成功，否则匹配失败，将会匹配可变长参数版本的 <code>test</code>。</p>
<p>C++11 版本下我们的许多操作变得更加符合直觉，实现也更加简洁明了。</p>
<p>试验：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Test1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; isComparable&lt;Test1&gt;::value &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; isComparable&lt;Test2&gt;::value &lt;&lt; std::endl; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<p>除此之外还有另一种方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> isComparable: std::false_type <span class="comment">// 继承而来的 value 成员为 false，下面类似。</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span>&lt;T, <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;() &lt; std::<span class="built_in">declval</span>&lt;T&gt;())&gt;: std::true_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>第一个版本的 <code>isComparable</code> 默认参数一定要设为 <code>bool</code>，也就是 <code>operator&lt;</code> 返回值的类型，原因是：</p>
<ul>
<li>当类模板有默认参数的时候，编译器会更加偏袒那个有默认参数的模板；</li>
<li>当带有默认参数的模板与另外一个偏特化模板参数一致的时候，则会优先选择那个偏特化的版本。</li>
</ul>
<p>于是当 <code>[T = Test1]</code>，偏特化版本模板的第二个参数也是 <code>bool</code>，于是选择了第二个偏特化版本的模板。</p>
<p>当 <code>[T = Test2]</code>，<strong>SFINAE</strong> 的规则让我们不得不选择第一个版本的模板。</p>
<h2 id="C-14-泛型-lambda"><a href="#C-14-泛型-lambda" class="headerlink" title="C++14 泛型 lambda"></a>C++14 泛型 <code>lambda</code></h2><p>C++14 让我们的匿名函数支持 <code>auto</code> 类型的参数。它的本质其实就是带有模板括号运算符的仿函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unnamed</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125; functor;</span><br></pre></td></tr></table></figure>

<p>因此 <strong>SFINAE</strong> 的技术也能够适用于它。</p>
<p>我们可以用泛型 <code>lambda</code> 来实现袖珍版的 <code>traits</code>。</p>
<p>先上效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="keyword">operator</span>&lt;<span class="params">(B <span class="type">const</span> &amp;)</span> <span class="type">const</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hasLess = <span class="built_in">is_valid</span>([] (<span class="keyword">auto</span> &amp;&amp;x) -&gt; <span class="keyword">decltype</span>(x &lt; x) &#123; &#125;);</span><br><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="number">43</span>)  &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="built_in">A</span>()) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="built_in">B</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comparableWith = <span class="built_in">is_valid</span>([] (<span class="keyword">auto</span> &amp;&amp;x, <span class="keyword">auto</span> &amp;&amp;y) -&gt; <span class="keyword">decltype</span>(x &lt; y) &#123; &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="number">43</span>, <span class="string">&quot;Abc&quot;</span>s) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="number">43</span>, <span class="number">72.2</span>)   &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="built_in">B</span>(), <span class="built_in">B</span>())   &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="built_in">A</span>(), <span class="built_in">B</span>())   &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>is_valid</code> 是个啥，好神奇。下面我们就来详细解释一下：</p>
<p>首先，它是一个<strong>工厂函数</strong>。产生 <code>is_valid_impl</code> 类型的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_valid_impl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    F _f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(Ts&amp;&amp;... ts)</span> -&gt; <span class="title">decltype</span><span class="params">(_f(ts...), <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">is_valid_impl</span><span class="params">(F &amp;&amp;f)</span>: _f(f) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Us&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Us&amp;&amp;... us)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">test</span>(us...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function">is_valid_impl&lt;F&gt; <span class="title">is_valid</span><span class="params">(F &amp;&amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">is_valid_impl</span>&lt;F&gt;(std::forward&lt;F&gt;(f)); &#125;</span><br></pre></td></tr></table></figure>

<p><code>is_valid_impl</code> 的工作原理：</p>
<ul>
<li>依靠 <code>is_valid_impl</code> 构造函数把仿函数对象 <code>_f</code> 初始化。</li>
<li><code>operator()</code> 从调用时的实参列表推导出来 <code>Us...</code> 将运算委任给 <code>test</code> 函数。</li>
<li>首先匹配第一个版本的 <code>test</code>，这个过程有 <strong>SFINAE</strong> 的参与：<code>decltype</code> 时，将形参代入 <code>_f</code>，而我们的 <code>_f</code> 形如：<code>[] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;</code>，如果参数无法进行某些指定操作，或者参数长度不匹配，那么第一个版本的 <code>test</code> 被 <code>SFINAE out</code>。否则匹配成功，返回 <code>true</code>。</li>
<li>匹配失败，这个时候就进入第二个版本的 <code>test</code>，其无论如何都会返回 <code>false</code>。</li>
</ul>
<p>由于 C++14 参数推导还不够智能，所以我们这里<strong>不得不使用</strong>一个工厂函数来帮助我们推导 <code>F</code> 的类型，而在后续标准，我们可以不再需要这个工厂函数，而直接使用构造函数了。</p>
<h2 id="C-17-void-t"><a href="#C-17-void-t" class="headerlink" title="C++17 void_t"></a>C++17 void_t</h2><p>C++17 引入了一个 类模板<code>std::void_t</code>，它可以干啥呢？接受一长串的类型，但自己永远是 <code>void</code>。它其实就是一个别名模板，长成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br></pre></td></tr></table></figure>

<p>现在可以方便地使用 <code>decltype</code> + 逗号表达式，来完成一长串的判断，而无需判断返回值类型了（有的时候返回值类型是难以判断的，比如返回值类型带有模板参数）。</p>
<p>下面给出一个终极版 <code>isComparable</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> isComparable: std::false_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;() &lt; std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">                                            std::<span class="built_in">declval</span>&lt;T&gt;() &gt; std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">                                            std::<span class="built_in">declval</span>&lt;T&gt;() &gt;= std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">                                            std::<span class="built_in">declval</span>&lt;T&gt;() &lt;= std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">                                            std::<span class="built_in">declval</span>&lt;T&gt;() == std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">                                            std::<span class="built_in">declval</span>&lt;T&gt;() != std::<span class="built_in">declval</span>&lt;T&gt;())&gt;&gt;: std::true_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="C-20-concepts"><a href="#C-20-concepts" class="headerlink" title="C++20 concepts"></a>C++20 concepts</h2><p>如前言所说，C++20 概念库或给 <strong>SFINAE</strong> 的时代画上一个句号。那么我们也用概念重写的 <code>isComparable</code> 为本文画上一个句号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_bool = std::is_convertible_v&lt;T, <span class="type">bool</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> isComparable =</span><br><span class="line">  <span class="built_in">requires</span> (T t)</span><br><span class="line">&#123;                            </span><br><span class="line">    &#123;t &gt;  t&#125; -&gt; is_bool; &#123;t &lt;  t&#125; -&gt; is_bool;</span><br><span class="line">    &#123;t &gt;= t&#125; -&gt; is_bool; &#123;t &lt;= t&#125; -&gt; is_bool;</span><br><span class="line">    &#123;t == t&#125; -&gt; is_bool; &#123;t != t&#125; -&gt; is_bool;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> isNotComparable = !isComparable&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>我们可以这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用不同的概念我们可以提供不同的重载函数版本（即便参数列表相同）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(isComparable <span class="keyword">auto</span>&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is comparable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(isNotComparable <span class="keyword">auto</span>&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is not comparable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">Test</span>());</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is comparable</span><br><span class="line">is not comparable</span><br></pre></td></tr></table></figure>

<p>当然我们可以把 <code>concepts</code> 和上面的那些类模板结合起来，用来做空基类优化，不过那就不是本文要讨论的内容了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>尽管我曾在前言说过，我们毋须为 <strong>SFINAE</strong> 技术的退出而悲伤，但我认为 <strong>SFINAE</strong> 技术是老一代 C++ 工程师智慧的结晶。二十多年过去，C++ 标准从跛脚逐步开始走向完善，使用 C++ 抽象的方法日趋成熟，我想这其中不无他们的功劳。在模板技术发展的过程中，许多东西都事出偶然，然而如果没有前人的不懈尝试，这些偶然又怎会成为已经发生的必然？</p>
<p>当然，<strong>SFINAE</strong> 作为 C++ 本身的一个语言规则，它仍然会在底层发挥作用。不得不直接倚赖底层的东西去解决上层的问题，这是 C++ 过去的缺陷。</p>
<p>人们始终不停地在探索这个语言的极限，我想这才是 C++ 吸引人的地方。</p>
<p>如果这篇文章能给读者带来一丝启发，那就再好不过了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><strong>Jean Guegant: An introduction to C++’s SFINAE concept: compile-time introspection of a class member</strong></em> [<a target="_blank" rel="noopener" href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html]">https://jguegant.github.io/blogs/tech/sfinae-introduction.html]</a> （我的 <strong>SFINAE</strong> 启蒙读物）</p>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://tsumugivolle77.github.io">Offensive 77</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/">https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
      
  <nav class="post-nav">  
      
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:endsieg77@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://x.com/Offensive771" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/Tsumugivolle77" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Offensive 77</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>