<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Golden Hours</title>
  
  <subtitle>眩しさだけわ、忘れなかった</subtitle>
  <link href="https://tsumugivolle77.github.io/atom.xml" rel="self"/>
  
  <link href="https://tsumugivolle77.github.io/"/>
  <updated>2024-10-25T05:15:25.955Z</updated>
  <id>https://tsumugivolle77.github.io/</id>
  
  <author>
    <name>Offensive 77</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SFINAE 的发展史</title>
    <link href="https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</id>
    <published>2024-10-24T16:00:00.000Z</published>
    <updated>2024-10-25T05:15:25.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SFINAE-的发展史"><a href="#SFINAE-的发展史" class="headerlink" title="SFINAE 的发展史"></a>SFINAE 的发展史</h1><p>本文写于2021年12月，发表在本人的老博客和校科协的网站上；现转载于此。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到 C++ 的模板技术，有一个术语不得不提：<strong>SFINAE</strong> (读作 Sfee-nay，<strong>S</strong>ubstitution <strong>F</strong>ailure is <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror )。这个技术使得 C++ 这样的静态语言在一定程度上可以实现类似反射的功能 (可以根据类型的特征，表现出不同的行为)。在 C++20 标准概念库发布之后，许多运用到 <strong>SFINAE</strong> 的场景都可以被概念取代，这一古老的方案也许也将退出到幕后。</p><p>当然，这不是一件值得悲伤的事情，这说明标准委员会在积极地寻求摆脱历史的包袱的途径。</p><p>这篇文章旨在向想要了解 <strong>SFINAE</strong> 的读者介绍这一技术的发展历史。</p><h2 id="什么是-SFINAE"><a href="#什么是-SFINAE" class="headerlink" title="什么是 SFINAE?"></a>什么是 <strong>SFINAE</strong>?</h2><p>任何人，看到那样一长串的英文解释，或许都会懵逼。<strong>替换失败不是一个错误？</strong>什么鬼？</p><p>更加具体地说，这句话的意思是，在<strong>模板实例化的过程中，替换失败不是一个错误。</strong></p><h2 id="C-98-的做法"><a href="#C-98-的做法" class="headerlink" title="C++98 的做法"></a>C++98 的做法</h2><p>下面我将以判断一个类是否拥有 <code>size_t size()</code> 方法为例，来深入 <strong>SFINAE</strong>。</p><p>我们希望，假如这个类拥有 <code>size</code> 方法，那么就调用这个方法，否则使用另外一个泛化版本的方法。</p><h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>我们定义一个结构体 <code>hasSize</code> 作为类的特征，假如这个类拥有 <code>size</code> 方法，那么 <code>hasSize::value</code> 将会是 <code>true </code> (或1)，否则为 <code>false</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T&gt;struct hasSize&#123;    &#x2F;&#x2F; Compile-time Boolean    typedef char yes;    typedef int  no;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Q:</strong> 你一定注意到了上面的 <code>typedef</code>，并且对此有些不解。它是做什么的？</p><p><strong>A:</strong> 它是用来做编译期的对错判断的。</p><p><strong>Q:</strong> 为什么要这么写？直接用函数返回 <code>true</code> 或 <code>false</code> 难道不好吗？</p><p><strong>A:</strong> 确实好，但是 C++98 的函数返回值只能在运行时获得。直到 C++11 引入 <code>constexpr</code> 之后，这一问题才得到改善。</p><p><strong>Q:</strong> 那为什么这么写就能达成我们的目的？</p><p><strong>A:</strong> 我们应该还记得 C 里的一个运算符，它长得有点像函数，但与它有关的求值却全都发生在编译期。那就是 <code>sizeof</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int a &#x3D; sizeof(int);const bool b &#x3D; sizeof(int) &#x3D;&#x3D; sizeof(char);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的两个赋值语句，其赋值号右边的值均可以在编译期求得。而看到第二个语句，你一定已经恍然大悟。</p><p>下面就是我们的 <strong>SFINAE</strong> 登场的时候了。</p><p>我们在结构体内加入另外一个脚手架结构体 <code>reallyHas</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename U, U u&gt; struct reallyHas;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在参数 <code>U</code> 中可以给出函数指针的类型，在参数 <code>u</code> 中给出成员函数的具体名字。</p><p>然后给出两个函数 <code>test</code> 的重载版本：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename U,          typename &#x3D; reallyHas&lt;size_t(U::*)() const, &amp;U::size&gt;&gt;static yes test(U) &#123; &#125;&#x2F;&#x2F; Fallback:static no test(...) &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个版本返回 <code>yes</code>，接受 <code>U</code> 类型的变量为参数，模板参数列表里第一个是 <code>U</code>，第二个参数是我们之前的脚手架 <code>reallyHas</code>。</p><p>第二个版本接受可变长参数。</p><p>匹配 <code>test</code> 版本的过程中，会发生这样的事：</p><ul><li><code>test</code> 从参数中推导出 <code>U</code> 的具体类型，代入模板的第一个参数，然后把所有的 <code>U</code> 替换成这个类型。</li><li>替换 (Substitution) 完毕，接着编译器会去查找实例化后 <code>test</code> 中和替换后 <code>U</code> 有关的部分（本例中就是 <code>size_t(U::*)() const</code> 类型的 <code>&amp;U::size</code>），假如它们不存在，那么这次替换就宣告失败 (Failure)。但替换失败不是一个错误 (Error)，编译器会接着匹配，直到所有候选名单 (<em>candidates</em>) 的成员都不匹配，才会报错。</li><li>随着第一个匹配失败，模板去匹配可变长参数版本的 <code>test</code>。这个版本无论如何一定能匹配成功，而它的返回值类型是 <code>no</code>。</li></ul><p>然后我们使用一个枚举常量 <code>value</code> 来接受结果：（C++11 之后便被 <code>constexpr</code> 取代）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum&#123;    value &#x3D; sizeof(test(T())) &#x3D;&#x3D; sizeof(yes)&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这一过程，我们并不需要函数具体的返回值，而只是对返回值的类型作操作。这冥冥之中也印证了一句话：C++的模板是编译期的多态，是类型的多态（或者也可以说，类型和值本身可以等价）。</p><p>当然上面的并不是最终版本，假如我们的 <code>size</code> 有两种可能的版本：</p><ul><li><code>size_t(U::*)() const</code></li><li><code>size_t(U::*)()</code></li></ul><p>那么我们就无法简单使用上面的做法了。</p><p>下面提供一种更加简洁的做法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T&gt;struct hasSize&#123;    typedef char yes;    typedef int  no;    template &lt;typename U, U u&gt; struct reallyHas;    template &lt;typename U&gt; static yes test(        reallyHas&lt;size_t(U::*)(), &amp;U::size&gt; *) &#123; &#125;    template &lt;typename U&gt; static yes test(        reallyHas&lt;size_t(U::*)() const, &amp;U::size&gt; *) &#123; &#125;    template &lt;typename&gt; static no test(...) &#123; &#125;    enum    &#123;        value &#x3D; sizeof(test&lt;T&gt;(int())) &#x3D;&#x3D; sizeof(yes)    &#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 C++ 整形可以隐式转化为指针，我们仍然会先匹配 <code>yes</code> 版本的 <code>test</code>。</p><h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><p>下面我们使用之前的 <code>hasSize</code> 来帮助我们实现目的。我们来引入另外一个工具人：<code>enable_if</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;bool, typename T&gt;struct enable_if&#123;    typedef T type;&#125;;template &lt;typename T&gt;struct enable_if&lt;false, T&gt;&#123; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来有点懵？不知道它要干嘛？我们继续实现我们的 <code>getSize</code> 函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T&gt;  typename enable_if&lt;hasSize&lt;T&gt;::value, size_t&gt;::typegetSize(const T &amp;obj)&#123;    std::cout &lt;&lt; &quot;obj has size&quot; &lt;&lt; std::endl;    return obj.size();&#125;template &lt;typename T&gt;&#x2F;* disable if: *&#x2F;  typename enable_if&lt;!hasSize&lt;T&gt;::value, size_t&gt;::typegetSize(const T &amp;obj)&#123;    std::cout &lt;&lt; &quot;obj has no size&quot; &lt;&lt; std::endl;    return sizeof(obj);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两处都得写上 <code>enable_if</code>，否则会产生二义性。（如果其中一个 <code>enable_if</code> 的参数1为 <code>true</code>，那么返回值是 <code>size_t</code>，那么另外一个 <code>enable_if</code> 必然没有返回值，所以它会被排除在候选名单之外，假如另外一个函数拥有返回值，那么这个时候编译器将会不清楚应该调用哪个版本的函数，从而产生 error）</p><p>下面来试验一下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::vector&lt;int&gt; v &#x3D; &#123;4, 5, 6, 7&#125;;char c &#x3D; &#39;c&#39;;std::cout &lt;&lt; getSize(v) &lt;&lt; std::endl;std::cout &lt;&lt; getSize(c) &lt;&lt; std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">obj has size4obj has no size1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间来到-C-11"><a href="#时间来到-C-11" class="headerlink" title="时间来到 C++11"></a>时间来到 C++11</h2><p>我们在讲述 C++98 的解决方法的时候，已经说过：许多东西到了 C++11 会有更好的解决办法。</p><p>现在我们终于可以介绍 C++11 了。</p><p>其实本来并没有 C++11，它最早的名字叫做 C++0x，因为人们坚信在二十一世纪的前十年 C++11 的标准就能够实现，然而实际上直到2011年，C++11 才正式发布。</p><p>C++11 为模板编程带来了许多的便利。</p><ul><li>首先是编译期表达式类型推导 <code>decltype</code>。</li><li>接着是 <code>std::declval</code>，这是一个模板函数，它允许我们构造一个类型 <code>T</code> 的临时量，而无需我们提供参数对其构造。</li><li>还有我们之前说过的 <code>constexpr</code>，也是千呼万唤始出来。</li><li><code>std::enable_if</code>，它进标准了。</li><li>当然还有新的标准库头文件，<code>type_traits</code>，它为我们提供了许许多多方便的 <code>traits</code>，我们不需要再自己手动实现了。</li></ul><p>在 C++11 中，我们将使用另外一个例子——判断一个类是否是可以比较大小的。(这里以小于号为例)</p><p>我们写一个类模板 <code>isComparable</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T&gt;struct isComparable&#123;    template &lt;typename U&gt;    static constexpr bool test(        decltype(std::declval&lt;U&gt;() &lt; std::declval&lt;U&gt;()) *)    &#123; return true; &#125;    template &lt;typename&gt;    static constexpr bool test(...) &#123; return false; &#125;&#x2F;&#x2F; C++11 initializer list    static constexpr bool value &#123; test&lt;T&gt;(int()) &#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在  <code>test</code> 的参数中用到了 <code>decltype</code> 和 <code>std::declval</code>。用 <code>declval</code> 来查询是否两个 <code>U</code> 类型的变量重载了（或者本身就拥有）<code>operator&lt;</code>，如果拥有，则匹配成功，否则匹配失败，将会匹配可变长参数版本的 <code>test</code>。</p><p>C++11 版本下我们的许多操作变得更加符合直觉，实现也更加简洁明了。</p><p>试验：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Test1&#123;public:    bool operator&lt;(Test1);&#125;;class Test2&#123; &#125;;std::cout &lt;&lt; isComparable&lt;Test1&gt;::value &lt;&lt; std::endl; &#x2F;&#x2F; 1std::cout &lt;&lt; isComparable&lt;Test2&gt;::value &lt;&lt; std::endl; &#x2F;&#x2F; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外还有另一种方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T,          typename &#x3D; bool&gt;struct isComparable: std::false_type&#x2F;&#x2F; 继承而来的 value 成员为 false，下面类似。&#123; &#125;;template &lt;typename T&gt;struct isComparable&lt;    T, decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;: std::true_type&#123; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个版本的 <code>isComparable</code> 默认参数一定要设为 <code>bool</code>，也就是 <code>operator&lt;</code> 返回值的类型，原因是：</p><ul><li>当类模板有默认参数的时候，编译器会更加偏袒那个有默认参数的模板；</li><li>当带有默认参数的模板与另外一个偏特化模板参数一致的时候，则会优先选择那个偏特化的版本。</li></ul><p>于是当 <code>[T = Test1]</code>，偏特化版本模板的第二个参数也是 <code>bool</code>，于是选择了第二个偏特化版本的模板。</p><p>当 <code>[T = Test2]</code>，<strong>SFINAE</strong> 的规则让我们不得不选择第一个版本的模板。</p><h2 id="C-14-泛型-lambda"><a href="#C-14-泛型-lambda" class="headerlink" title="C++14 泛型 lambda"></a>C++14 泛型 <code>lambda</code></h2><p>C++14 让我们的匿名函数支持 <code>auto</code> 类型的参数。它的本质其实就是带有模板括号运算符的仿函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto f &#x3D; [] (auto x) &#123; return x; &#125;;&#x2F;&#x2F; equivalent to:struct Unnamed&#123;    template &lt;typename T&gt;    auto operator()(T x) &#123; return x; &#125;&#125; functor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此 <strong>SFINAE</strong> 的技术也能够适用于它。</p><p>我们可以用泛型 <code>lambda</code> 来实现袖珍版的 <code>traits</code>。</p><p>先上效果：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123; &#125;;class B&#123;public:    bool operator&lt;(B const &amp;) const &#123; &#125;&#125;;auto hasLess &#x3D; is_valid([] (auto &amp;&amp;x) -&gt; decltype(x &lt; x) &#123; &#125;);std::cout &lt;&lt; std::boolalpha;std::cout &lt;&lt; hasLess(43)  &lt;&lt; std::endl;std::cout &lt;&lt; hasLess(A()) &lt;&lt; std::endl;std::cout &lt;&lt; hasLess(B()) &lt;&lt; std::endl;auto comparableWith &#x3D; is_valid(    [] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;);std::cout &lt;&lt; comparableWith(43, &quot;Abc&quot;s) &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(43, 72.2)   &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(B(), B())   &lt;&lt; std::endl;std::cout &lt;&lt; comparableWith(A(), B())   &lt;&lt; std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">truefalsetruefalsetruetruefalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <code>is_valid</code> 是个啥，好神奇。下面我们就来详细解释一下：</p><p>首先，它是一个<strong>工厂函数</strong>。产生 <code>is_valid_impl</code> 类型的对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename F&gt;struct is_valid_impl&#123;private:    F _f;    template &lt;typename... Ts&gt;    static constexpr auto test(Ts&amp;&amp;... ts)        -&gt; decltype(_f(ts...), true)    &#123; return true; &#125;    &#x2F;&#x2F; fallback    static constexpr bool test(...)    &#123; return false; &#125;public:    constexpr explicit is_valid_impl(F &amp;&amp;f): _f(f) &#123; &#125;    template &lt;typename... Us&gt;    constexpr auto operator()(Us&amp;&amp;... us)    &#123; return test(us...); &#125;&#125;;template &lt;typename F&gt;is_valid_impl&lt;F&gt; is_valid(F &amp;&amp;f)&#123; return is_valid_impl&lt;F&gt;(std::forward&lt;F&gt;(f)); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>is_valid_impl</code> 的工作原理：</p><ul><li>依靠 <code>is_valid_impl</code> 构造函数把仿函数对象 <code>_f</code> 初始化。</li><li><code>operator()</code> 从调用时的实参列表推导出来 <code>Us...</code> 将运算委任给 <code>test</code> 函数。</li><li>首先匹配第一个版本的 <code>test</code>，这个过程有 <strong>SFINAE</strong> 的参与：<code>decltype</code> 时，将形参代入 <code>_f</code>，而我们的 <code>_f</code> 形如：<code>[] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;</code>，如果参数无法进行某些指定操作，或者参数长度不匹配，那么第一个版本的 <code>test</code> 被 <code>SFINAE out</code>。否则匹配成功，返回 <code>true</code>。</li><li>匹配失败，这个时候就进入第二个版本的 <code>test</code>，其无论如何都会返回 <code>false</code>。</li></ul><p>由于 C++14 参数推导还不够智能，所以我们这里<strong>不得不使用</strong>一个工厂函数来帮助我们推导 <code>F</code> 的类型，而在后续标准，我们可以不再需要这个工厂函数，而直接使用构造函数了。</p><h2 id="C-17-void-t"><a href="#C-17-void-t" class="headerlink" title="C++17 void_t"></a>C++17 void_t</h2><p>C++17 引入了一个 类模板<code>std::void_t</code>，它可以干啥呢？接受一长串的类型，但自己永远是 <code>void</code>。它其实就是一个别名模板，长成这样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename...&gt;using void_t &#x3D; void;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在可以方便地使用 <code>decltype</code> + 逗号表达式，来完成一长串的判断，而无需判断返回值类型了（有的时候返回值类型是难以判断的，比如返回值类型带有模板参数）。</p><p>下面给出一个终极版 <code>isComparable</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T,          typename &#x3D; void&gt;struct isComparable: std::false_type&#123; &#125;;template &lt;typename T&gt;struct isComparable&lt;T, std::void_t&lt;decltype(    std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;(),    std::declval&lt;T&gt;() &gt; std::declval&lt;T&gt;(),    std::declval&lt;T&gt;() &gt;&#x3D; std::declval&lt;T&gt;(),    std::declval&lt;T&gt;() &lt;&#x3D; std::declval&lt;T&gt;(),    std::declval&lt;T&gt;() &#x3D;&#x3D; std::declval&lt;T&gt;(),    std::declval&lt;T&gt;() !&#x3D; std::declval&lt;T&gt;())&gt;&gt;: std::true_type&#123; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-20-concepts"><a href="#C-20-concepts" class="headerlink" title="C++20 concepts"></a>C++20 concepts</h2><p>如前言所说，C++20 概念库或给 <strong>SFINAE</strong> 的时代画上一个句号。那么我们也用概念重写的 <code>isComparable</code> 为本文画上一个句号。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;typename T&gt;concept is_bool &#x3D; std::is_convertible_v&lt;T, bool&gt;;template &lt;typename T&gt;concept isComparable &#x3D;  requires (T t)&#123;                                &#123;t &gt;  t&#125; -&gt; is_bool; &#123;t &lt;  t&#125; -&gt; is_bool;    &#123;t &gt;&#x3D; t&#125; -&gt; is_bool; &#123;t &lt;&#x3D; t&#125; -&gt; is_bool;    &#123;t &#x3D;&#x3D; t&#125; -&gt; is_bool; &#123;t !&#x3D; t&#125; -&gt; is_bool;&#125;;template &lt;typename T&gt;concept isNotComparable &#x3D; !isComparable&lt;T&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以这么使用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 使用不同的概念我们可以提供不同的重载函数版本（即便参数列表相同）void foo(isComparable auto&amp;&amp;)&#123;    std::cout &lt;&lt; &quot;is comparable&quot; &lt;&lt; std::endl;&#125;void foo(isNotComparable auto&amp;&amp;)&#123;    std::cout &lt;&lt; &quot;is not comparable&quot; &lt;&lt; std::endl;&#125;class Test &#123; &#125;;foo(1);foo(Test());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">is comparableis not comparable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然我们可以把 <code>concepts</code> 和上面的那些类模板结合起来，用来做空基类优化，不过那就不是本文要讨论的内容了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>尽管我曾在前言说过，我们毋须为 <strong>SFINAE</strong> 技术的退出而悲伤，但我认为 <strong>SFINAE</strong> 技术是老一代 C++ 工程师智慧的结晶。二十多年过去，C++ 标准从跛脚逐步开始走向完善，使用 C++ 抽象的方法日趋成熟，我想这其中不无他们的功劳。在模板技术发展的过程中，许多东西都事出偶然，然而如果没有前人的不懈尝试，这些偶然又怎会成为已经发生的必然？</p><p>当然，<strong>SFINAE</strong> 作为 C++ 本身的一个语言规则，它仍然会在底层发挥作用。不得不直接倚赖底层的东西去解决上层的问题，这是 C++ 过去的缺陷。</p><p>人们始终不停地在探索这个语言的极限，我想这才是 C++ 吸引人的地方。</p><p>如果这篇文章能给读者带来一丝启发，那就再好不过了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><strong>Jean Guegant: An introduction to C++’s SFINAE concept: compile-time introspection of a class member</strong></em> [<a href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html]">https://jguegant.github.io/blogs/tech/sfinae-introduction.html]</a> （我的 <strong>SFINAE</strong> 启蒙读物）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SFINAE-的发展史&quot;&gt;&lt;a href=&quot;#SFINAE-的发展史&quot; class=&quot;headerlink&quot; title=&quot;SFINAE 的发展史&quot;&gt;&lt;/a&gt;SFINAE 的发展史&lt;/h1&gt;&lt;p&gt;本文写于2021年12月，发表在本人的老博客和校科协的网站上；现转载</summary>
      
    
    
    
    
    <category term="C++" scheme="https://tsumugivolle77.github.io/tags/C/"/>
    
    <category term="SFINAE" scheme="https://tsumugivolle77.github.io/tags/SFINAE/"/>
    
    <category term="templates" scheme="https://tsumugivolle77.github.io/tags/templates/"/>
    
  </entry>
  
  <entry>
    <title>鸟白岛巡礼指北</title>
    <link href="https://tsumugivolle77.github.io/2024/10/25/%E9%B8%9F%E7%99%BD%E5%B2%9B%E5%B7%A1%E7%A4%BC%E6%8C%87%E5%8C%97/"/>
    <id>https://tsumugivolle77.github.io/2024/10/25/%E9%B8%9F%E7%99%BD%E5%B2%9B%E5%B7%A1%E7%A4%BC%E6%8C%87%E5%8C%97/</id>
    <published>2024-10-24T16:00:00.000Z</published>
    <updated>2024-10-25T03:48:09.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="鸟白岛巡礼指北"><a href="#鸟白岛巡礼指北" class="headerlink" title="鸟白岛巡礼指北"></a>鸟白岛巡礼指北</h1><p>本文搬运自本人的b站专栏。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天是2024年7月26日。本人刚刚从日本返回中国，总计在日本停留了九天，其中前三天在高松（包括男木岛、女木岛、直岛）度过。决定写一篇专栏来记录我的第一次巡礼之旅。这是一场身体很累，但心灵却得到治愈的旅途。在这之中，我收获了许多意外的惊喜。</p><p>由于秋叶原Cafe&amp;Bar MENU咖啡吧的Summer Pockets联动（原先定于7月25日结束，现已延迟到9月1日结束，需要提前预约），在高松旅程结束之后，笔者一路北上经由： “高松 –轮渡–&gt; 直岛 –轮渡–&gt; 宇野 –JR+新干线–&gt; 大阪 –阪急–&gt; 京都 –JR（原定新干线，但当天新干线脱轨。不是万不得已请不要使用JR，会绕很远的路且费用更高）–&gt; 东京”的线路最终到达秋叶原（途中当然在各地都进行了游玩）。</p><p>此外，如果不打算前往京都，飞机也是一个很好的选择（京都没有任何的公共机场，<del>如果你长了螺旋桨，那么忽视这一段</del>）。如果没有鸟白岛巡礼以外的其他目的，那么全程几乎不需要用到JR或是新干线等轨道交通（在这种情况下，也没有必要购买交通卡）。</p><p>接下来，本文将会囊括以下内容：</p><p>住宿的选项；<br>乘坐渡轮的细节；<br>巡礼线路选择、岛上的交通方式；<br>可能会错过的一些巡礼地点（例：三座岛外部的一些圣地)；<br>季节性的活动（男木岛灯台祭、咖啡厅联动等)；<br>巡礼可以选择的（软件)工具；<br>在不会日语的情况下，你可以做什么准备工作。<br>本文中的内容并不一定是我的亲身经历，有一部分来自于问询其他巡礼者，仅在本文中将其记录，以备今后二周目巡礼时查看。如果这篇文章可以在未来的某个时间帮到某个人，那么就再好不过了。</p><h2 id="Part-1-住宿的选项"><a href="#Part-1-住宿的选项" class="headerlink" title="Part 1. 住宿的选项"></a>Part 1. 住宿的选项</h2><h3 id="1-1-住在高松或直岛"><a href="#1-1-住在高松或直岛" class="headerlink" title="1.1 住在高松或直岛"></a>1.1 住在高松或直岛</h3><p>高松或直岛本身旅游开发比较完善，因此你可以使用住宿软件十分轻松地订到这两处的酒店。如果你选择住在高松，那么请注意选择邻近高松港的酒店。假如你打算居住在游戏中的加藤家<br>（现实中位于直岛的石井商店），那么请提前大约4个月预订（消息来源：我在巡礼过程中，在石井商店遇到的一位中国SP粉丝）。</p><h3 id="1-2-住在男木岛"><a href="#1-2-住在男木岛" class="headerlink" title="1.2 住在男木岛"></a>1.2 住在男木岛</h3><p>如果你是一个紬厨，希望拍摄到黄昏或夜晚的灯塔；或者渴望体验游戏中羽依里、細、静久三人合宿的剧情，那么住宿在男木岛是一个不错的选择。</p><p>我并没有居住在男木岛，在巡礼回来之前也并不知晓男木岛住宿的方法，直到我询问了一位在男木岛过夜的中国SP粉丝，得到的答案如下：</p><p>岛上的旅店；<br>灯塔露营；<br>住丰爷家。<br>男木岛上的旅店目前暂且无法通过线上方式进行预订，需要线下自行沟通。而关于丰爷，我会在后文介绍。可以预料到，住在男木岛对于初次巡礼的人（尤其是社恐二次元）很难实行，也具有很大的不确定性。</p><h3 id="1-3-住在女木岛"><a href="#1-3-住在女木岛" class="headerlink" title="1.3 住在女木岛"></a><del>1.3 住在女木岛</del></h3><p><del>嗯？谁会住在女木岛。</del></p><h2 id="Part-2-乘坐渡轮的细节"><a href="#Part-2-乘坐渡轮的细节" class="headerlink" title="Part 2. 乘坐渡轮的细节"></a>Part 2. 乘坐渡轮的细节</h2><p>前往男木岛和女木岛以及前往直岛的航线分别由：雌雄岛海运株式会社以及四国海运株式会社运营。二者的售票处位于相距几百米的不同地点，如果不知道具体位置，可以用日语或简单的英语询问工作人员。</p><p>对于各交通节点之间的可达关系，可以这样概括：高松港、男木岛和女木岛之间两两可达，高松港、宇野和直岛之间两两可达。</p><h3 id="2-1-雌雄岛航线"><a href="#2-1-雌雄岛航线" class="headerlink" title="2.1 雌雄岛航线"></a>2.1 雌雄岛航线</h3><p>由于男木岛和女木岛属于较冷门的旅游景点，每天的渡轮班次相对较少，而且每天很早就结束运营。其海运时间表如下图所示：<br><img src="/images/img.png" alt="images/img.png"></p><p>注意：发船时刻提前半个小时开始售票。从图中可以得知，如果选择在8月的前20天出行，则班次会相对较多，行程安排会更加自由。</p><h3 id="2-2-四国航线"><a href="#2-2-四国航线" class="headerlink" title="2.2 四国航线"></a>2.2 四国航线</h3><p>直岛往返的渡轮时刻表，如下图绿色部分所示（红色部分是岛上大巴、蓝色部分是直岛艺术馆的免费巴士):<br><img src="/images/img_1.png" alt="images/img_1.png"></p><p>上图为前往直岛、下图为离开直岛。</p><h2 id="Part-3-巡礼线路选择、岛上的交通方式"><a href="#Part-3-巡礼线路选择、岛上的交通方式" class="headerlink" title="Part 3. 巡礼线路选择、岛上的交通方式"></a>Part 3. 巡礼线路选择、岛上的交通方式</h2><h3 id="3-1-巡礼线路选择"><a href="#3-1-巡礼线路选择" class="headerlink" title="3.1 巡礼线路选择"></a>3.1 巡礼线路选择</h3><p>巡礼的顺序大概可以分成以下四类：</p><ul><li>男木女木、直岛；</li><li>直岛、男木女木；</li><li>女木男木、直岛；</li><li>直岛、女木男木。</li><li>首先，个人而言，我并不推荐将女木岛放在男木岛前面，尽管它距离高松港最近。我更加推荐以直岛或男木岛作为巡礼的起点。这两者之间，我会更加优先参观男木岛。对于初次巡礼的时间安排上，我的建议是两到三天。在直岛上完全可以待上两天时间，去享受夏季的阳光沙滩，或者参观一下岛上的艺术馆，感受“度过快乐暑假的秘诀”。如无特殊情况（例如准备在男木岛过夜），男木岛和女木岛一天足矣。</li></ul><p>接下来，介绍一下优先男木岛的理由。这里就不得不提到之前所说的丰爷（twitter id:@nekopoketoyoji)。除去已经关门的直岛小卖铺，男木岛丰爷的ねこポケハウス（NekopokeHouse）是三座岛上Summer Pockets元素最为浓厚的地方。丰爷的家里接待过无数各地的SP厨和爱猫人士，你可以在那找到各种的SP周边、在来访者日记中留下自己的痕迹、和其他到访的SP厨交流心得、得到一些巡礼的指南、或者吸一会猫。丰爷是一个非常有意思的老爷爷，经常在推特上冲浪。</p><p>很遗憾的是，我前往男木岛的那天，丰爷刚好因为有事前往高松。我只在男木岛役馆（村公所）门口见到他一面，并且没认出来他，我的紬痛T引起了他的注意。后来，我们在推特上也有一些友好的交流。如果有能力的话，完全可以在巡礼之前先在推特上和丰爷提前联系，打个招呼。</p><p>丰爷的家就在男木岛下船后，右手边役所旁边的小道往里。（小道旁边有一片墓地，可以方便定位。没有恶意）<br><img src="/images/img_2.png" alt="images/img_2.png"><br><img src="/images/img_3.png" alt="images/img_3.png"><br><img src="/images/img_4.png" alt="images/img_4.png"><br><img src="/images/img_5.png" alt="images/img_5.png"></p><h3 id="3-2-岛上交通方式"><a href="#3-2-岛上交通方式" class="headerlink" title="3.2 岛上交通方式"></a>3.2 岛上交通方式</h3><p>男木岛：有且只有步行，岛上道路坡度比较大，注意安全、记得补充体力。不要打扰到岛上的居民。 </p><p>女木岛：主要的巡礼地点是鬼岛大洞窟（鸥线），下船后购买巴士票直达。 </p><p>直岛：租借自行车（宫浦港旁边非常显眼的一家店铺）和公交车（100日元可以坐到岛上任意一站，可以在港口附近的售票处找一本直岛指南（如下图）<br>随手查阅路线和运营时间）。直岛上的交通是最方便的。（如果你重新玩一遍《夏日口袋》的话，会发现羽依里在上岛后不久即遭遇了公交车，这点十分还原）<br><img src="/images/img_6.png" alt="images/img_6.png"><br><img src="/images/img_7.png" alt="images/img_7.png"></p><h2 id="Part-4-可能会错过的一些巡礼地点"><a href="#Part-4-可能会错过的一些巡礼地点" class="headerlink" title="Part 4. 可能会错过的一些巡礼地点"></a>Part 4. 可能会错过的一些巡礼地点</h2><p>游戏标题画面的出处在直岛地中艺术馆可以找到。不太好找，也不太像。是日本友人带我找到的。<br><img src="/images/img_8.png" alt="images/img_8.png"><br><img src="/images/img_9.png" alt="images/img_9.png"></p><p>白羽线吃可丽饼的cg在JR宇野站的停车场内（我当时并没有想起来去找）。<br><img src="/images/img_10.png" alt="images/img_10.png"></p><p>迷途橘的原型在国营常陆海滨公园（从东京使用公共交通过去得4个小时以上），建议4、5月份花期的时候去。这里我还闹了一个乌龙，找到另一个名字很像的地方了，不过当时时间也很紧，就没再找下去了。如果打算去，建议在附近住宿并且安排一天的时间。图片来自谷歌地图。<br><img src="/images/img_11.png" alt="images/img_11.png"></p><p>其他的暂时没想起来。</p><h2 id="Part-5-季节性的活动（2024年）"><a href="#Part-5-季节性的活动（2024年）" class="headerlink" title="Part 5. 季节性的活动（2024年）"></a>Part 5. 季节性的活动（2024年）</h2><p>Summer Pockets的许多活动的开始&#x2F;结束都与7月25日有关，游戏中这一天是羽依里上岛的日子。如果你提前几个月在做圣地巡礼的计划（例如希望以此作为毕业旅行），那么建议将旅行的时间定在这一天之后。更具体一点：这一天之后的周末、或是8月31日（紬的生日）。如果这样计划，碰上特别的活动的概率会最大化。例如，2024年7月25日之后的第一个周六，也就是7月27日，是Key社Summer Festival售卖SP周边开始的时间。同样是这一年，7月25日开始到8月31日结束，是男木岛灯台祭的期间，起的早一些有可能遇上意外之喜；如果更特殊一点，碰上了这一段时间的周末，那么也许就有机会进到灯塔内部参观。</p><p>当然也有例外，秋叶原的SP咖啡厅联动原定于7月25日截止（现在延迟到9月1日）。关于咖啡厅的预约（一般需要提供日本手机号），我通过本人经验和与其他人交流，总结出了以下方法：</p><p>直接通过推特私信与工作人员联系。这种方法可能不太礼貌，但我成功了；<br>在手机号一栏填写中国驻日大使馆的电话号码；<br>使用咖啡厅的提问网站进行问询和预约，给清楚信息，说 明来意：<a href="https://menu-store.com/inquiry%EF%BC%9B">https://menu-store.com/inquiry；</a><br>“没必要这么麻烦，我有日本手机号”，那么直接预订即可。<br>联动咖啡厅的部分商品在秋叶原电波会馆的K-Books中被溢价倒卖，本人十分反感这种行为，因为我没在咖啡厅买到我想要的爱丽丝紬徽章。如果实在有想要单收的周边，可以去那看看。<br><img src="/images/img_12.png" alt="images/img_12.png"><br><img src="/images/img_13.png" alt="images/img_13.png"><br><img src="/images/img_14.png" alt="images/img_14.png"><br><img src="/images/img_15.png" alt="images/img_15.png"></p><h2 id="Part-6-巡礼可以选择的（软件）工具"><a href="#Part-6-巡礼可以选择的（软件）工具" class="headerlink" title="Part 6. 巡礼可以选择的（软件）工具"></a>Part 6. 巡礼可以选择的（软件）工具</h2><p>首先，出国在外，我建议你不要使用华为手机。提前买好日本流量卡。带好充电宝，手机开着导航耗电飞快。</p><p>我所使用到的工具大致如下：</p><ul><li>Google地图：在日本比较好用的地图工具；</li><li>Google翻译：如果你在日语不好的情况下英语又不太好&#x2F;需要和不会使用英语的日本人交流，那么可以使用。提前熟悉功能（例如语音翻译等)，谷歌翻译的质量还是堪忧的；</li><li>Anitabi动画巡礼网站：<a href="https://anitabi.cn/map,%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E6%96%B9%E4%BE%BF%E5%9C%B0%E6%9F%A5%E6%89%BE%E5%88%B0%E5%B7%A1%E7%A4%BC%E5%9C%B0%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9B">https://anitabi.cn/map,可以比较方便地查找到巡礼地点的位置；</a></li><li>换乘案内：一个查询日本换乘路线的APP；</li><li>Agoda：酒店预订工具，使用别的软件替代也无所谓；</li><li>其他（待补充）</li></ul><h2 id="Part-7-在不会日语的情况下，你可以做什么准备工作"><a href="#Part-7-在不会日语的情况下，你可以做什么准备工作" class="headerlink" title="Part 7. 在不会日语的情况下，你可以做什么准备工作"></a>Part 7. 在不会日语的情况下，你可以做什么准备工作</h2><p>在一个陌生的环境下，你的外表是最具冲击力的语言。如果你想第一时间让别人知道自己的目的，你可以选择穿一件喜欢角色的痛T（如果经济实力不够，淘宝定制的就足够了）。这是本人定制的痛T：<br><img src="/images/img_16.png" alt="images/img_16.png"></p><p>这是我的成果：<br><img src="/images/img_17.png" alt="images/img_17.png"></p><p>此外，提前在推特上关注丰爷等人的账号，熟悉外面的SP圈子，实时记录行程，可以帮助你更快地找到同好。</p><p>日本人<del>废话</del>说的不少，提前记一些常用日本礼貌用语，可以给他人留下一个好印象。他们做事的条条框框也比较多，可以提前熟悉，给自己一个比较好的体验。比如说：日本人走路会固定走某一侧，记得留意脚下的方向标志；在自动扶梯上记得空出右边的一条通路给赶时间的人行走；用完餐起身之前说一句「ご馳走樣でした。」表示对厨师的感谢；需要其他人帮忙的时候私密马赛一下绝对没有错。最重要的一点是，注意日本店铺的营业时间：许多（不是全部）店铺10点才开门（石井商店是11点），而晚上6点（比如说直岛上的餐厅）~8点就已经关门了；如果需要吃早餐，可以去随处可见的711、全家福超市（巡礼的体力消耗不小，建议不要忘记吃早餐）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>祝愿读到这篇专栏的人能够从中获取一些有用的信息，可以在鸟白岛找到探求之物、找到自己、找到想做的事!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;鸟白岛巡礼指北&quot;&gt;&lt;a href=&quot;#鸟白岛巡礼指北&quot; class=&quot;headerlink&quot; title=&quot;鸟白岛巡礼指北&quot;&gt;&lt;/a&gt;鸟白岛巡礼指北&lt;/h1&gt;&lt;p&gt;本文搬运自本人的b站专栏。&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; cl</summary>
      
    
    
    
    
    <category term="Summer Pockets" scheme="https://tsumugivolle77.github.io/tags/Summer-Pockets/"/>
    
    <category term="travel" scheme="https://tsumugivolle77.github.io/tags/travel/"/>
    
  </entry>
  
</feed>
