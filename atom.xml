<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Golden Hours</title>
  
  <subtitle>眩しさだけわ、忘れなかった</subtitle>
  <link href="https://tsumugivolle77.github.io/atom.xml" rel="self"/>
  
  <link href="https://tsumugivolle77.github.io/"/>
  <updated>2026-02-11T20:37:28.950Z</updated>
  <id>https://tsumugivolle77.github.io/</id>
  
  <author>
    <name>Offensive 77</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quantum Dissipative System</title>
    <link href="https://tsumugivolle77.github.io/2026/02/11/Quantum-Dissipative-System/"/>
    <id>https://tsumugivolle77.github.io/2026/02/11/Quantum-Dissipative-System/</id>
    <published>2026-02-11T20:33:21.000Z</published>
    <updated>2026-02-11T20:37:28.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><strong>2025 WiSe, by: Offensive77</strong></p><figure><p><img src="/images/qds/qds-in-a-nutshell.jpg" style="width:95.0%"></p><figcaption><p>QDS in a Nutshell</p></figcaption></figure><h1 id="Key-Tricks-Performed-in-This-Topic"><a href="#Key-Tricks-Performed-in-This-Topic" class="headerlink" title="Key Tricks Performed in This Topic"></a>Key Tricks Performed in This Topic</h1><h2 id="Statistical-Operator"><a href="#Statistical-Operator" class="headerlink" title="Statistical Operator"></a>Statistical Operator</h2><p>Statistical operator (or density operator) reflects the statistical<br>attributes of our system. It works similarly as the probability density<br>function in probability theory. It allows us to define something like<br>expectation and thus correlation.</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="114.027ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 50400 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Missing or unrecognized delimiter for \left" title="Missing or unrecognized delimiter for \left"><rect data-background="true" width="50400" height="950" y="-200"></rect><title>Missing or unrecognized delimiter for \left</title><g data-mml-node="mtext" style="font-family: serif;"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">\left\langle \hat{O} \right\rangle = \operatorname{tr}\left{ \hat{O}\hat{W} \right},</text></g></g></g></g></svg></mjx-container>[]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="quantum mechanics" scheme="https://tsumugivolle77.github.io/categories/quantum-mechanics/"/>
    
    
    <category term="open system" scheme="https://tsumugivolle77.github.io/tags/open-system/"/>
    
    <category term="decoherence" scheme="https://tsumugivolle77.github.io/tags/decoherence/"/>
    
    <category term="Caldeira-Leggett" scheme="https://tsumugivolle77.github.io/tags/Caldeira-Leggett/"/>
    
    <category term="Markov Approximation" scheme="https://tsumugivolle77.github.io/tags/Markov-Approximation/"/>
    
  </entry>
  
  <entry>
    <title>Properties of Arnoldi process for skew symmetric matrices</title>
    <link href="https://tsumugivolle77.github.io/2024/12/17/Properties-of-Arnoldi-process-for-skew-symmetric-matrices/"/>
    <id>https://tsumugivolle77.github.io/2024/12/17/Properties-of-Arnoldi-process-for-skew-symmetric-matrices/</id>
    <published>2024-12-17T17:10:21.000Z</published>
    <updated>2024-12-17T17:13:42.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="question">Question</span></h2><p><img src="/images/arnoldi_process/QQ_1734455471666.png" alt="alt text"></p><h2><span id="solution-incomplete">Solution (incomplete)</span></h2><p><img src="/images/arnoldi_process/QQ_1734455553573.png" alt="alt text"><br><img src="/images/arnoldi_process/image.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="maths" scheme="https://tsumugivolle77.github.io/categories/maths/"/>
    
    
    <category term="Numerical Linear Algebra" scheme="https://tsumugivolle77.github.io/tags/Numerical-Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>NODE Übungsmenü</title>
    <link href="https://tsumugivolle77.github.io/2024/12/03/Prove-Trumpet-Bound/"/>
    <id>https://tsumugivolle77.github.io/2024/12/03/Prove-Trumpet-Bound/</id>
    <published>2024-12-03T21:47:39.000Z</published>
    <updated>2024-12-04T19:02:44.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="grönwall-inequality">Grönwall inequality</span></h2><p><img src="/images/trumpet_bound/QQ_1733338929744.png" alt="alt text"></p><h2><span id="question-0">Question 0</span></h2><p><img src="/images/trumpet_bound/QQ_1733262696794.png" alt="alt text"></p><h2><span id="proof-0">Proof 0</span></h2><p><img src="/images/trumpet_bound/QQ_1733262613332.png" alt="alt text"></p><h2><span id="question-1">Question 1</span></h2><p><img src="/images/trumpet_bound/QQ_1733338958588.png" alt="alt text"></p><h2><span id="proof-1">Proof 1</span></h2><p><img src="/images/trumpet_bound/image.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="maths" scheme="https://tsumugivolle77.github.io/categories/maths/"/>
    
    
    <category term="Numerical Optimization" scheme="https://tsumugivolle77.github.io/tags/Numerical-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>Literarische Quotationen</title>
    <link href="https://tsumugivolle77.github.io/2024/12/01/Zitate-von-1984/"/>
    <id>https://tsumugivolle77.github.io/2024/12/01/Zitate-von-1984/</id>
    <published>2024-12-01T13:30:17.000Z</published>
    <updated>2025-03-14T14:00:49.201Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Nun war er im Begriff, ein Tagebuch anzufangen. Das war nicht illegal (<strong>nichts war illegal, da es keine Gesetze gab</strong>), aber im Fall der Entdeckung war es ziemlich sicher, dass man dafür mit dem Tod oder wenigstens fünfundzwanzig Jahren Arbeitslager bestraft würde.</p><hr><p>Mit diesen Kindern, dachte er, muss die arme Frau <em>ein Leben ständigen Schrecken führen</em>. Noch ein Jahr oder zwei, dann würde sie von ihnen Tag und Nacht auf <em>Anzeichen von Unorthodoxie</em> beobachtet. Heutzutage waren fast alle Kinder furchtbar. Am schlimmsten war, dass Organisationen wie die Spione sie systematisch zu unkontrollierbaren kleinen Wilden machten, was bei ihnen aber keinerlei Hang zur Rebellion gegen die Partei und alles, was damit zusammenhing. Die Lieder, die Aufmärsche, die Fahnen, das Wandern, der Drill mit Holzgewehren, das Brüllen von Slogans, die Anbetung des Großen Bruders - das alles war für sie eine Art großartigen Spiels. <em>Ihre ganze Wildheit wurde nach außen gelenkt, gegen Staatsfeinde, Ausländer, Verräter, Saboteure, Gedankenverbrecher.</em> Es war beinahe normal, dass Leute über dreißig sich vor den eigenen Kindern fürchteten.</p><hr><p>«Wir werden uns an dem Ort treffen, an dem es keine Dunkelheit gibt.»</p><hr><p>Unten auf der Straße ließ der Wind das abgerissene Plakat hin und her flappen, und das Wort ENGSOZ erschien und verschwand stoßweise. Engsoz. Die heiligen Grundsätze von Engsoz. <em>Neusprech, Doppeldenk, Veränderbarkeit der Vergangenheit</em>. <strong>Er fühlte sich, als ginge er durch Wälder am Meeresgrund, verloren in einer monströsen Welt, in der er selbst das Monster war. Die Vergangenheit war tot, die Zukunft ist unvorstellbar. Welche Gewissheit hat er denn, dass auch nur ein einzigerjetzt lebender Mensch auf seiner Seite war? Und wie konnte er wissen, ob die Herrschaft der Partei nicht ewig dauern würde?</strong> Wie eine Antwort kamen ihm die drei Slogans auf der weißen Fassade des Ministeriums der Wahrheit in den Sinn:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KRIEG IST FRIEDE</span><br><span class="line">FREIHEIT IST KNECHTSCHAFT</span><br><span class="line">UNWISSEN IST STÄRKE</span><br></pre></td></tr></table></figure><hr><p>Aus dem Abgrund des Grauens, in dem wir heute halb blind herumtasten mit verstörter und zerbrochener Seele, blicke ich immer wieder auf zu jenen alten Sternbildern, die über meiner Kindheit glänzten, und tröste mich mit dem ererbten Vertrauen, daß dieser Rückfall dereinst nur als ein Intervall erscheinen wird in dem ewigen Rhythmus des Voran und Voran.</p><hr><p>Aber nur die sogenannte ›akademische‹ Bildung, die zur Universität führte, verlieh in jenen Zeiten des ›aufgeklärten‹ Liberalismus vollen Wert; darum gehörte es zum Ehrgeiz jeder ›guten‹ Familie, daß wenigstens einer ihrer Söhne vor dem Namen irgendeinen Doktortitel trug.</p><hr><p>Und der einzige wirklich beschwingte Glücksmoment, den ich der Schule zu danken habe, wurde der Tag, da ich ihre Tür für immer hinter mir zuschlug.</p><hr><p><strong>Noch als Gymnasiast wurde uns, wenn wir eine schlechte Note in irgendeinem nebansächlichen Gegenstand nach Hause brachten, gedroht, man werde uns aus der Schule nehmen und ein Handwerk lernen lassen - die schlimmste Drohung, die es in der bürgerlichen Welt gab: Rückfall ins Proletariat -</strong>, und wenn junge Menschen im ehrlichsten Bildungsverlangen bei Erwachsenen Aufklärung über ernste zeitliche Probleme suchten, wurden sie abgekanzelt mit dem hochmütigen »Das verstehst du noch nicht«.</p><hr><p>Überall waren wir die Stoßtruppe und der Vortrupp jeder Art neuer Kunst, nur weil sie neu war, nur weil sie die Welt verändern wollte für uns, die jetzt an die Reihe kamen, ihr Leben zu leben. Weil wir fühlten, ›nostra res agitur‹.</p><hr><p>Was man an seinen Muskeln versäumt hat, holt sich später noch nach; der Aufschwung zum Geistigen, die innere Griffkraft der Seele dagegen, übt sich einzig in jenen entscheidenden Jahren der Formung, und nur wer früh seine Seele weit auszuspannen gelernt, vermag später die ganze Welt in sich zu fassen.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="literature" scheme="https://tsumugivolle77.github.io/categories/literature/"/>
    
    
    <category term="1984" scheme="https://tsumugivolle77.github.io/tags/1984/"/>
    
    <category term="Welt von Gestern" scheme="https://tsumugivolle77.github.io/tags/Welt-von-Gestern/"/>
    
  </entry>
  
  <entry>
    <title>IVP Sensitivity Matrices: Properties</title>
    <link href="https://tsumugivolle77.github.io/2024/11/19/IVP-Sensitivity-Matrices-Properties/"/>
    <id>https://tsumugivolle77.github.io/2024/11/19/IVP-Sensitivity-Matrices-Properties/</id>
    <published>2024-11-19T12:26:11.000Z</published>
    <updated>2024-11-19T12:57:03.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/images/IVP_Sensitivity/QQ_1732019135862.png" alt="alt text"><br><img src="/images/IVP_Sensitivity/QQ_1732019284142.png" alt="alt text"><br>All the other properties are easy to show, except a notable one (g).</p><p>The proof is given above:<br><img src="/images/IVP_Sensitivity/QQ_1732019391013.png" alt="alt text"><br>this is given by applying the chain rule.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="maths" scheme="https://tsumugivolle77.github.io/categories/maths/"/>
    
    
    <category term="Numerical Optimization" scheme="https://tsumugivolle77.github.io/tags/Numerical-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>Heidelberg Bird Observation</title>
    <link href="https://tsumugivolle77.github.io/2024/11/15/Heidelberg-Bird-Observation/"/>
    <id>https://tsumugivolle77.github.io/2024/11/15/Heidelberg-Bird-Observation/</id>
    <published>2024-11-15T22:53:19.000Z</published>
    <updated>2024-11-20T20:43:49.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="black-headed-gull">Black-Headed Gull</span></h2><p><img src="/images/life-in-germany/AFE2CFC6EEAEED7A0A46AB02C479DD66.jpg" alt="alt text"><br><img src="/images/life-in-germany/BF504CAFC6BE288F5E45B93C1C563248.jpg" alt="alt text"></p><h2><span id="swan">Swan</span></h2><p><img src="/images/life-in-germany/3C3B2C44B07531FD30F2F6EB62F62FD3.jpg" alt="alt text"></p><h2><span id="crow">Crow</span></h2><p><img src="/images/life-in-germany/B8379A028FCB47E7A11CB59BCE7EA847.jpg" alt="alt text"><br><img src="/images/life-in-germany/EE17E651FA005A15AA9BEF8DF720FFFF.jpg" alt="alt text"></p><h2><span id="egyptian-goose">Egyptian Goose</span></h2><p><img src="/images/life-in-germany/0A8CADCAA1DDE3BB418E35C252944A3F.jpg" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    <category term="life records" scheme="https://tsumugivolle77.github.io/categories/life-records/"/>
    
    
    <category term="Deutschland" scheme="https://tsumugivolle77.github.io/tags/Deutschland/"/>
    
    <category term="life" scheme="https://tsumugivolle77.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Life in Germany: Prologue</title>
    <link href="https://tsumugivolle77.github.io/2024/11/05/Life-in-Germany-Prologue/"/>
    <id>https://tsumugivolle77.github.io/2024/11/05/Life-in-Germany-Prologue/</id>
    <published>2024-11-05T01:26:24.000Z</published>
    <updated>2024-11-20T20:48:06.194Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="first-challenge-german-visa">First Challenge: German Visa</span></h2><p>Well, I waited exatly 2 months until I received it (from 2. Sep. to 2. Nov.). Quite slow ja.<br>I expected to celebrate Halloween (for the very first time) in Germany but that did not come true. :(</p><p>Ok, part of the reasons for being so late are on me, this July I spent my Summer holiday in Japan. Hence, I started to make preparations until August. However, visiting Torishirojima has the highest priority in my heart than any other things. Plus, a period of 2 months is way too long under any circumstances and in any country. Unacceptable man.</p><p>Verdammt, Bundesamt für Auswärtige Angelegenheiten, FICK DICH.<br><img src="/images/life-in-germany/IMG_20241102_150231.jpg" alt="alt text"></p><p>­The following parts of this article would be updated in the next days.</p><h2><span id="day-1-shanghai-gt-frankfurt-am-main">Day 1: Shanghai -&gt; Frankfurt am Main</span></h2><p>I arrived at Flughafen Frankfurt (FRA) after 14 hours of airtrip. Frankfurt is not as “big” as I imagined before. Yeah, It’s not that modern and shocking when you put it with Shanghai or Tokyo, at the very first glance. But the goods price here is quite big. I bought a coke and a choco with 2,5€ for both at a shop near Frankfurt train station. (They would cost ca. 1,5€ in Germany as usual.)</p><p>I only stay here for one night. No time for further exploration.</p><h2><span id="day-2-frankfurt-am-main-gt-heidelberg">Day 2: Frankfurt am Main -&gt; Heidelberg</span></h2><p>I ordered a Ride on FreeNow on the second morning with ca. 110€ and go to have a look at the apartment I will move in, at Im Eichwald, Heidelberg. Well, it’s not even fully furnished. I would stay in the nearby hotel for a week. Unlucky again :(.<br><img src="/images/life-in-germany/IMG_20241107_085150.jpg" alt="Near Frankfurt Train Station"><br><img src="/images/life-in-germany/IMG_20241107_100622.jpg" alt="Im Eichwald"></p><p>After that, I went down the steep hill roads to have my first glance at Heidelberg Alte Brücke. It was a quite long way down there with several catholic churchs scatter on it. I also see for the first time the trains running on the same roads with cars.<br><img src="/images/life-in-germany/IMG_20241107_155525.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241107_162334.jpg" alt="alt text"></p><p>With feet you will need over 1 hour to get to that site. However, the awesome landscape alongside River Neckar worths all the tiredness and efforts. The Winter sky in Germany is said to be always cloudy (at least for this day, all day long). But I can clearly imagine how gourgeous it would look like in Spring or Summer.<br><img src="/images/life-in-germany/IMG_20241107_164348.jpg" alt="Neckar River"><br><img src="/images/life-in-germany/IMG_20241107_165304.jpg" alt="Studentmensa"><br><img src="/images/life-in-germany/IMG_20241107_170405.jpg" alt="Alte Brücke"><br><img src="/images/life-in-germany/IMG_20241107_170708.jpg" alt="Heidelberg Schloss maybe"></p><p>I also tasted the food in the students’ restaurant. It’s not bad (day 5 edit: no it’s bad, you would not like to eat it all the year). It’s just so strange and “eatable” to a minimum anyway.<br><img src="/images/life-in-germany/IMG_20241107_172856.jpg" alt="Essen von Cthulhu"></p><p>The way back to Im Eichwald was a nightware: OVER 30 degree rampway starting from Rohrbach to Im Eichwald. There’s also a graveyard on the way. I realized then, life here without a bicyclec (day 5 edit: without public transport) will be a big challenge and no joke, I will become a top athelete before I graduate from Uni Heidelberg. :) Besides, I also find other problems already. I must solve them asap and yeah the most important, buy a bicycle tomorrow.</p><p>So tired and so much for this day.. Gute Nacht.</p><h2><span id="day-4-relish-the-moment-alongside-the-neckar-river">Day 4: Relish the Moment alongside the Neckar River</span></h2><p>This day was the first Saturday since I’d been here. And the first day of sun. Good weather always give man good moods. I managed to fix some problem (with my Chinese SIM Card) last night. There’re still many things undone.</p><p>In the morning I ride down the countryroad to Kaufland and DM to get a German phone number (the fellow students recommended me to buy a prepaid Vodafone CallYa SIM Card) and to buy some life necessities. On the way here and there I encountered a big school of pigeons, so cute.<br><img src="/images/life-in-germany/IMG_20241109_084929.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_090745.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_093742.jpg" alt="alt text"></p><p>I bought a Döner Kebab for lunch. I must say it was a lifesaver in one such Sahara of Fine Foods: Deutschland. A Drehspiess mit Hähnchen is sold for 6€. Well, it’s not only goat in quality (the taste) but also fantastic when it comes to quantity. I love Kebab.<br><img src="/images/life-in-germany/IMG_20241109_115651.jpg" alt="alt text"></p><p>The Neckar River under sufficient sunlight is quite beatiful. I took several photos.<br><img src="/images/life-in-germany/IMG_20241109_123035.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_123845.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_124410.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_125054.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241109_125803.jpg" alt="alt text"></p><p>Enjoy it, at least at present.</p><h2><span id="day-5-try-the-public-transport-for-the-first-time">Day 5: Try the public transport for the first time</span></h2><p>I think the time and money I spent for the previous days are sadly wasted :(. The public transport is way too easy and convenient.</p><p>Also tried the Pide mit Döner. It’s peak.<br><img src="/images/life-in-germany/IMG_20241110_181649.jpg" alt="alt text"></p><p>So much for today. Many of the problems are solved. Life is changing towards a better direction. Happy.</p><h2><span id="new-week-uni-life-and-great-challenges">New Week, Uni life and great challenges</span></h2><p>OK. Use one picture to describe the first Uni days:<br><img src="/images/life-in-germany/9aaad007ea56aad635303d6811ed2e9e.jpg" alt="alt text"><br>“Everyday in the d**ned uni is not good.”</p><p>Pick your opponent:</p><p>English with</p><ul><li>Sauerkraut flavour (Deutsch)</li><li>Curry flavour (Indian)</li><li>Kebab flavour (Turkish)</li><li>…</li></ul><p>Well, nix klappt, tue ich nix. :(</p><p>But there’re still few good things in the dull life, like the (Black-headed) gulls I encountered on my way to the shitty students’ canteen. I even don’t believe they can be true. Almost the same as what I saw on Megijima. (but that was fake)</p><p>Let’s have a look:<br><img src="/images/life-in-germany/AFE2CFC6EEAEED7A0A46AB02C479DD66.jpg" alt="alt text"></p><p>The fake ones in Megijima:<br><img src="/images/life-in-germany/70859054005d0824db08dbc4e7fcb6e9.jpg" alt="alt text"></p><p>I will move to my rented house this Friday. I think things are really getting better but I need to emphasize more on study and work hard..</p><h2><span id="move-into-the-apartment">Move into the apartment</span></h2><p>Hello new life!<br><img src="/images/life-in-germany/FD2DBA198849782A1D79345D31B7A7CD.jpg" alt="alt text"><br><img src="/images/life-in-germany/3CAC5C4F7ABDC62223A7A4C8FCA69CDD.jpg" alt="alt text"></p><h2><span id="snippets-of-the-days">Snippets of the Days</span></h2><p><img src="/images/life-in-germany/1C46FD38810DA6755F42C730127F196F.jpg" alt="alt text"><br><img src="/images/life-in-germany/8F984354B88F10602699E4CC09443165.jpg" alt="alt text"><br><img src="/images/life-in-germany/8295A9368AD9B9A877566A221E47B2EA.jpg" alt="alt text"><br><img src="/images/life-in-germany/B1A13BA628DFD57CABB5E91B00795870.jpg" alt="alt text"><br><img src="/images/life-in-germany/CDA2215B9B24B63E61D43B62FB60F0A4.jpg" alt="alt text"><br><img src="/images/life-in-germany/FDD9079C7A16B29DFD0A72C244BC52FF.jpg" alt="alt text"></p><h2><span id="sidequest">Sidequest</span></h2><h3><span id="konomi">Konomi</span></h3><p>Konomi is a Japanese 喫茶店 running by a Japanese Grandma near Peterskirche (Peter’s Church) in Heidelberg Altstadt. It’s famous in the city and has awesome vibe inside. Matcha Latte and Japanese snacks like Takoyaki, Udon, Soba etc. are the signature products. I tried Matcha Latte (with standard milk) and Soba. That was good.</p><p>「Entschuldigung, 写真オーケー？」</p><p>「Haha, ja!」</p><p>Then I took the photos:<br><img src="/images/life-in-germany/IMG_20241108_111908.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241108_113444.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241108_113726.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241108_113738.jpg" alt="alt text"><br><img src="/images/life-in-germany/IMG_20241108_105931.jpg" alt="alt text"></p><p>After I finished the dish, I gave the Grandma a classical 「ご馳走様でした！」. She was really delighted. :) I guess. I also bet that she came from Kyoto.</p><h3><span id="min-ramen-bar">Min Ramen Bar</span></h3><p><img src="/images/life-in-germany/FFBCBF50EE8F784671DACAB99E4C1746.jpg" alt="alt text"><br><img src="/images/life-in-germany/7E9B2E82ADD74ABEF146DD4BA9513C3E.jpg" alt="alt text"></p><h3><span id="bust-on-bismarckplatz">Bust on Bismarckplatz</span></h3><p><img src="/images/life-in-germany/806BC2F9A5C3DA1B98D21505E9FD24E2.jpg" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;[object Object]&quot; class=&quot;aplaye</summary>
      
    
    
    
    
    <category term="Deutschland" scheme="https://tsumugivolle77.github.io/tags/Deutschland/"/>
    
    <category term="life" scheme="https://tsumugivolle77.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>SFINAE 的发展史</title>
    <link href="https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>https://tsumugivolle77.github.io/2024/10/25/SFINAE%20%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/</id>
    <published>2024-10-24T22:00:00.000Z</published>
    <updated>2024-11-19T13:06:47.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文写于2021年12月，发布在本人的老博客和校科协的网站上；现转载于此。</p><h2><span id="前言">前言</span></h2><p>说到 C++ 的模板技术，有一个术语不得不提：<strong>SFINAE</strong> (读作 Sfee-nay，<strong>S</strong>ubstitution <strong>F</strong>ailure is <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror )。这个技术使得 C++ 这样的静态语言在一定程度上可以实现类似反射的功能 (可以根据类型的特征，表现出不同的行为)。在 C++20 标准概念库发布之后，许多运用到 <strong>SFINAE</strong> 的场景都可以被概念取代，这一古老的方案也许也将退出到幕后。</p><p>当然，这不是一件值得悲伤的事情，这说明标准委员会在积极地寻求摆脱历史的包袱的途径。</p><p>这篇文章旨在向想要了解 <strong>SFINAE</strong> 的读者介绍这一技术的发展历史。</p><span id="more"></span><h2><span id="什么是-sfinae">什么是 <strong>SFINAE</strong>?</span></h2><p>任何人，看到那样一长串的英文解释，或许都会懵逼。<strong>替换失败不是一个错误？</strong>什么鬼？</p><p>更加具体地说，这句话的意思是，在<strong>模板实例化的过程中，替换失败不是一个错误。</strong></p><h2><span id="c98-的做法">C++98 的做法</span></h2><p>下面我将以判断一个类是否拥有 <code>size_t size()</code> 方法为例，来深入 <strong>SFINAE</strong>。</p><p>我们希望，假如这个类拥有 <code>size</code> 方法，那么就调用这个方法，否则使用另外一个泛化版本的方法。</p><h3><span id="traits">traits</span></h3><p>我们定义一个结构体 <code>hasSize</code> 作为类的特征，假如这个类拥有 <code>size</code> 方法，那么 <code>hasSize::value</code> 将会是 <code>true </code> (或1)，否则为 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasSize</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compile-time Boolean</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>  no;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Q:</strong> 你一定注意到了上面的 <code>typedef</code>，并且对此有些不解。它是做什么的？</p><p><strong>A:</strong> 它是用来做编译期的对错判断的。</p><p><strong>Q:</strong> 为什么要这么写？直接用函数返回 <code>true</code> 或 <code>false</code> 难道不好吗？</p><p><strong>A:</strong> 确实好，但是 C++98 的函数返回值只能在运行时获得。直到 C++11 引入 <code>constexpr</code> 之后，这一问题才得到改善。</p><p><strong>Q:</strong> 那为什么这么写就能达成我们的目的？</p><p><strong>A:</strong> 我们应该还记得 C 里的一个运算符，它长得有点像函数，但与它有关的求值却全都发生在编译期。那就是 <code>sizeof</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> b = <span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br></pre></td></tr></table></figure><p>上面的两个赋值语句，其赋值号右边的值均可以在编译期求得。而看到第二个语句，你一定已经恍然大悟。</p><p>下面就是我们的 <strong>SFINAE</strong> 登场的时候了。</p><p>我们在结构体内加入另外一个脚手架结构体 <code>reallyHas</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, U u&gt; <span class="keyword">struct</span> <span class="title class_">reallyHas</span>;</span><br></pre></td></tr></table></figure><p>我们在参数 <code>U</code> 中可以给出函数指针的类型，在参数 <code>u</code> 中给出成员函数的具体名字。</p><p>然后给出两个函数 <code>test</code> 的重载版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">          <span class="keyword">typename</span> = reallyHas&lt;<span class="built_in">size_t</span>(U::*)() <span class="type">const</span>, &amp;U::size&gt;&gt;</span><br><span class="line"><span class="type">static</span> yes <span class="built_in">test</span>(U) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback:</span></span><br><span class="line"><span class="type">static</span> no <span class="built_in">test</span>(...) &#123; &#125;</span><br></pre></td></tr></table></figure><p>第一个版本返回 <code>yes</code>，接受 <code>U</code> 类型的变量为参数，模板参数列表里第一个是 <code>U</code>，第二个参数是我们之前的脚手架 <code>reallyHas</code>。</p><p>第二个版本接受可变长参数。</p><p>匹配 <code>test</code> 版本的过程中，会发生这样的事：</p><ul><li><code>test</code> 从参数中推导出 <code>U</code> 的具体类型，代入模板的第一个参数，然后把所有的 <code>U</code> 替换成这个类型。</li><li>替换 (Substitution) 完毕，接着编译器会去查找实例化后 <code>test</code> 中和替换后 <code>U</code> 有关的部分（本例中就是 <code>size_t(U::*)() const</code> 类型的 <code>&amp;U::size</code>），假如它们不存在，那么这次替换就宣告失败 (Failure)。但替换失败不是一个错误 (Error)，编译器会接着匹配，直到所有候选名单 (<em>candidates</em>) 的成员都不匹配，才会报错。</li><li>随着第一个匹配失败，模板去匹配可变长参数版本的 <code>test</code>。这个版本无论如何一定能匹配成功，而它的返回值类型是 <code>no</code>。</li></ul><p>然后我们使用一个枚举常量 <code>value</code> 来接受结果：（C++11 之后便被 <code>constexpr</code> 取代）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>(<span class="built_in">T</span>())) == <span class="built_in">sizeof</span>(yes)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一过程，我们并不需要函数具体的返回值，而只是对返回值的类型作操作。这冥冥之中也印证了一句话：C++的模板是编译期的多态，是类型的多态（或者也可以说，类型和值本身可以等价）。</p><p>当然上面的并不是最终版本，假如我们的 <code>size</code> 有两种可能的版本：</p><ul><li><code>size_t(U::*)() const</code></li><li><code>size_t(U::*)()</code></li></ul><p>那么我们就无法简单使用上面的做法了。</p><p>下面提供一种更加简洁的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasSize</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> yes;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>  no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, U u&gt; <span class="keyword">struct</span> <span class="title class_">reallyHas</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">static</span> yes <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        reallyHas&lt;<span class="type">size_t</span>(U::*)(), &amp;U::size&gt; *)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function"><span class="type">static</span> yes <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        reallyHas&lt;<span class="type">size_t</span>(U::*)() <span class="type">const</span>, &amp;U::size&gt; *)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="function"><span class="type">static</span> no <span class="title">test</span><span class="params">(...)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="built_in">int</span>())) == <span class="built_in">sizeof</span>(yes)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 C++ 整形可以隐式转化为指针，我们仍然会先匹配 <code>yes</code> 版本的 <code>test</code>。</p><h3><span id="enable_if">enable_if</span></h3><p>下面我们使用之前的 <code>hasSize</code> 来帮助我们实现目的。我们来引入另外一个工具人：<code>enable_if</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">false</span>, T&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><p>看起来有点懵？不知道它要干嘛？我们继续实现我们的 <code>getSize</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;hasSize&lt;T&gt;::value, <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj has size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">/* disable if: */</span></span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;!hasSize&lt;T&gt;::value, <span class="type">size_t</span>&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">getSize</span><span class="params">(<span class="type">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj has no size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两处都得写上 <code>enable_if</code>，否则会产生二义性。（如果其中一个 <code>enable_if</code> 的参数1为 <code>true</code>，那么返回值类型是 <code>size_t</code>，那么另外一个 <code>enable_if</code> 必然没有返回值类型（也就是type成员），所以它会被排除在候选名单之外，假如另外一个函数拥有返回值类型，那么这个时候编译器将会不明白应该调用哪个版本的函数，从而产生 error）</p><p>下面来试验一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">getSize</span>(v) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">getSize</span>(c) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj has size</span><br><span class="line">4</span><br><span class="line">obj has no size</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2><span id="时间来到-c11">时间来到 C++11</span></h2><p>我们在讲述 C++98 的解决方法的时候，已经说过：许多东西到了 C++11 会有更好的解决办法。</p><p>现在我们终于可以介绍 C++11 了。</p><p>其实本来并没有 C++11，它最早的名字叫做 C++0x，因为人们坚信在二十一世纪的前十年 C++11 的标准就能够实现，然而实际上直到2011年，C++11 才正式发布。</p><p>C++11 为模板编程带来了许多的便利。</p><ul><li>首先是编译期表达式类型推导 <code>decltype</code>。</li><li>接着是 <code>std::declval</code>，这是一个模板函数，它允许我们构造一个类型 <code>T</code> 的临时量，而无需我们提供参数对其构造。</li><li>还有我们之前说过的 <code>constexpr</code>，也是千呼万唤始出来。</li><li><code>std::enable_if</code>，它进标准了。</li><li>当然还有新的标准库头文件，<code>type_traits</code>，它为我们提供了许许多多方便的 <code>traits</code>，我们不需要再自己手动实现了。</li></ul><p>在 C++11 中，我们将使用另外一个例子——判断一个类是否是可以比较大小的。(这里以小于号为例)</p><p>我们写一个类模板 <code>isComparable</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">decltype</span>(std::declval&lt;U&gt;() &lt; std::declval&lt;U&gt;()) *)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(...)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="comment">// C++11 initializer list</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value &#123; <span class="built_in">test</span>&lt;T&gt;(<span class="built_in">int</span>()) &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在  <code>test</code> 的参数中用到了 <code>decltype</code> 和 <code>std::declval</code>。用 <code>declval</code> 来查询是否两个 <code>U</code> 类型的变量重载了（或者本身就拥有）<code>operator&lt;</code>，如果拥有，则匹配成功，否则匹配失败，将会匹配可变长参数版本的 <code>test</code>。</p><p>C++11 版本下我们的许多操作变得更加符合直觉，实现也更加简洁明了。</p><p>试验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Test1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; isComparable&lt;Test1&gt;::value &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; isComparable&lt;Test2&gt;::value &lt;&lt; std::endl; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>除此之外还有另一种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> isComparable: std::false_type</span><br><span class="line"><span class="comment">// 继承而来的 value 成员为 false，下面类似。</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span>&lt;</span><br><span class="line">    T, <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;() &lt; std::<span class="built_in">declval</span>&lt;T&gt;())</span><br><span class="line">&gt;: std::true_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><p>第一个版本的 <code>isComparable</code> 默认参数一定要设为 <code>bool</code>，也就是 <code>operator&lt;</code> 返回值的类型，原因是：</p><ul><li>当类模板有默认参数的时候，编译器会更加偏袒那个有默认参数的模板；</li><li>当带有默认参数的模板与另外一个偏特化模板参数一致的时候，则会优先选择那个偏特化的版本。</li></ul><p>于是当 <code>[T = Test1]</code>，偏特化版本模板的第二个参数也是 <code>bool</code>，于是选择了第二个偏特化版本的模板。</p><p>当 <code>[T = Test2]</code>，<strong>SFINAE</strong> 的规则让我们不得不选择第一个版本的模板。</p><h2><span id="c14-泛型-lambda">C++14 泛型 <code>lambda</code></span></h2><p>C++14 让我们的匿名函数支持 <code>auto</code> 类型的参数。它的本质其实就是带有模板括号运算符的仿函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unnamed</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125; functor;</span><br></pre></td></tr></table></figure><p>因此 <strong>SFINAE</strong> 的技术也能够适用于它。</p><p>我们可以用泛型 <code>lambda</code> 来实现袖珍版的 <code>traits</code>。</p><p>先上效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="keyword">operator</span>&lt;<span class="params">(B <span class="type">const</span> &amp;)</span> <span class="type">const</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hasLess = <span class="built_in">is_valid</span>([] (<span class="keyword">auto</span> &amp;&amp;x) -&gt; <span class="keyword">decltype</span>(x &lt; x) &#123; &#125;);</span><br><span class="line">std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="number">43</span>)  &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="built_in">A</span>()) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">hasLess</span>(<span class="built_in">B</span>()) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comparableWith = <span class="built_in">is_valid</span>(</span><br><span class="line">    [] (<span class="keyword">auto</span> &amp;&amp;x, <span class="keyword">auto</span> &amp;&amp;y) -&gt; <span class="keyword">decltype</span>(x &lt; y) &#123; &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="number">43</span>, <span class="string">&quot;Abc&quot;</span>s) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="number">43</span>, <span class="number">72.2</span>)   &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="built_in">B</span>(), <span class="built_in">B</span>())   &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">comparableWith</span>(<span class="built_in">A</span>(), <span class="built_in">B</span>())   &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个 <code>is_valid</code> 是个啥，好神奇。下面我们就来详细解释一下：</p><p>首先，它是一个<strong>工厂函数</strong>。产生 <code>is_valid_impl</code> 类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_valid_impl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    F _f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(Ts&amp;&amp;... ts)</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="title">decltype</span><span class="params">(_f(ts...), <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">is_valid_impl</span><span class="params">(F &amp;&amp;f)</span>: _f(f) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Us&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Us&amp;&amp;... us)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">test</span>(us...); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function">is_valid_impl&lt;F&gt; <span class="title">is_valid</span><span class="params">(F &amp;&amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">is_valid_impl</span>&lt;F&gt;(std::forward&lt;F&gt;(f)); &#125;</span><br></pre></td></tr></table></figure><p><code>is_valid_impl</code> 的工作原理：</p><ul><li>依靠 <code>is_valid_impl</code> 构造函数把仿函数对象 <code>_f</code> 初始化。</li><li><code>operator()</code> 从调用时的实参列表推导出来 <code>Us...</code> 将运算委任给 <code>test</code> 函数。</li><li>首先匹配第一个版本的 <code>test</code>，这个过程有 <strong>SFINAE</strong> 的参与：<code>decltype</code> 时，将形参代入 <code>_f</code>，而我们的 <code>_f</code> 形如：<code>[] (auto &amp;&amp;x, auto &amp;&amp;y) -&gt; decltype(x &lt; y) &#123; &#125;</code>，如果参数无法进行某些指定操作，或者参数长度不匹配，那么第一个版本的 <code>test</code> 被 <code>SFINAE out</code>。否则匹配成功，返回 <code>true</code>。</li><li>匹配失败，这个时候就进入第二个版本的 <code>test</code>，其无论如何都会返回 <code>false</code>。</li></ul><p>由于 C++14 参数推导还不够智能，所以我们这里<strong>不得不使用</strong>一个工厂函数来帮助我们推导 <code>F</code> 的类型，而在后续标准，我们可以不再需要这个工厂函数，而直接使用构造函数了。</p><h2><span id="c17-void_t">C++17 void_t</span></h2><p>C++17 引入了一个 类模板<code>std::void_t</code>，它可以干啥呢？接受一长串的类型，但自己永远是 <code>void</code>。它其实就是一个别名模板，长成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">void_t</span> = <span class="type">void</span>;</span><br></pre></td></tr></table></figure><p>现在可以方便地使用 <code>decltype</code> + 逗号表达式，来完成一长串的判断，而无需判断返回值类型了（有的时候返回值类型是难以判断的，比如返回值类型带有模板参数）。</p><p>下面给出一个终极版 <code>isComparable</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> isComparable: std::false_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isComparable</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() &lt; std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() &gt; std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() &gt;= std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() &lt;= std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() == std::<span class="built_in">declval</span>&lt;T&gt;(),</span><br><span class="line">    std::<span class="built_in">declval</span>&lt;T&gt;() != std::<span class="built_in">declval</span>&lt;T&gt;())&gt;&gt;: std::true_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><h2><span id="c20-concepts">C++20 concepts</span></h2><p>如前言所说，C++20 概念库或给 <strong>SFINAE</strong> 的时代画上一个句号。那么我们也用概念重写的 <code>isComparable</code> 为本文画上一个句号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_bool = std::is_convertible_v&lt;T, <span class="type">bool</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> isComparable =</span><br><span class="line">  <span class="built_in">requires</span> (T t)</span><br><span class="line">&#123;                            </span><br><span class="line">    &#123;t &gt;  t&#125; -&gt; is_bool; &#123;t &lt;  t&#125; -&gt; is_bool;</span><br><span class="line">    &#123;t &gt;= t&#125; -&gt; is_bool; &#123;t &lt;= t&#125; -&gt; is_bool;</span><br><span class="line">    &#123;t == t&#125; -&gt; is_bool; &#123;t != t&#125; -&gt; is_bool;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> isNotComparable = !isComparable&lt;T&gt;;</span><br></pre></td></tr></table></figure><p>我们可以这么使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用不同的概念我们可以提供不同的重载函数版本（即便参数列表相同）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(isComparable <span class="keyword">auto</span>&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is comparable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(isNotComparable <span class="keyword">auto</span>&amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is not comparable&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">Test</span>());</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is comparable</span><br><span class="line">is not comparable</span><br></pre></td></tr></table></figure><p>当然我们可以把 <code>concepts</code> 和上面的那些类模板结合起来，用来做空基类优化，不过那就不是本文要讨论的内容了。</p><h2><span id="后记">后记</span></h2><p>尽管我曾在前言说过，我们毋须为 <strong>SFINAE</strong> 技术的退出而悲伤，但我认为 <strong>SFINAE</strong> 技术是老一代 C++ 工程师智慧的结晶。二十多年过去，C++ 标准从跛脚逐步开始走向完善，使用 C++ 抽象的方法日趋成熟，我想这其中不无他们的功劳。在模板技术发展的过程中，许多东西都事出偶然，然而如果没有前人的不懈尝试，这些偶然又怎会成为已经发生的必然？</p><p>当然，<strong>SFINAE</strong> 作为 C++ 本身的一个语言规则，它仍然会在底层发挥作用。不得不直接倚赖底层的东西去解决上层的问题，这是 C++ 过去的缺陷。</p><p>人们始终不停地在探索这个语言的极限，我想这才是 C++ 吸引人的地方。</p><p>如果这篇文章能给读者带来一丝启发，那就再好不过了。</p><h2><span id="参考">参考</span></h2><p><em><strong>Jean Guegant: An introduction to C++’s SFINAE concept: compile-time introspection of a class member</strong></em> [<a href="https://jguegant.github.io/blogs/tech/sfinae-introduction.html]">https://jguegant.github.io/blogs/tech/sfinae-introduction.html]</a> （我的 <strong>SFINAE</strong> 启蒙读物）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文写于2021年12月，发布在本人的老博客和校科协的网站上；现转载于此。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说到 C++ 的模板技术，有一个术语不得不提：&lt;strong&gt;SFINAE&lt;/strong&gt; (读作 Sfee-nay，&lt;strong&gt;S&lt;/strong&gt;ubstitution &lt;strong&gt;F&lt;/strong&gt;ailure is &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;A&lt;/strong&gt;n &lt;strong&gt;E&lt;/strong&gt;rror )。这个技术使得 C++ 这样的静态语言在一定程度上可以实现类似反射的功能 (可以根据类型的特征，表现出不同的行为)。在 C++20 标准概念库发布之后，许多运用到 &lt;strong&gt;SFINAE&lt;/strong&gt; 的场景都可以被概念取代，这一古老的方案也许也将退出到幕后。&lt;/p&gt;
&lt;p&gt;当然，这不是一件值得悲伤的事情，这说明标准委员会在积极地寻求摆脱历史的包袱的途径。&lt;/p&gt;
&lt;p&gt;这篇文章旨在向想要了解 &lt;strong&gt;SFINAE&lt;/strong&gt; 的读者介绍这一技术的发展历史。&lt;/p&gt;</summary>
    
    
    
    <category term="programming" scheme="https://tsumugivolle77.github.io/categories/programming/"/>
    
    
    <category term="C++" scheme="https://tsumugivolle77.github.io/tags/C/"/>
    
    <category term="SFINAE" scheme="https://tsumugivolle77.github.io/tags/SFINAE/"/>
    
    <category term="templates" scheme="https://tsumugivolle77.github.io/tags/templates/"/>
    
  </entry>
  
  <entry>
    <title>鸟白岛巡礼指北</title>
    <link href="https://tsumugivolle77.github.io/2024/10/25/%E9%B8%9F%E7%99%BD%E5%B2%9B%E5%B7%A1%E7%A4%BC%E6%8C%87%E5%8C%97/"/>
    <id>https://tsumugivolle77.github.io/2024/10/25/%E9%B8%9F%E7%99%BD%E5%B2%9B%E5%B7%A1%E7%A4%BC%E6%8C%87%E5%8C%97/</id>
    <published>2024-10-24T22:00:00.000Z</published>
    <updated>2024-11-19T13:06:36.662Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="[object Object]" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>本文搬运自本人的b站专栏。</p><h2><span id="写在前面">写在前面</span></h2><p>今天是2024年7月26日。本人刚刚从日本返回中国，总计在日本停留了九天，其中前三天在高松（包括男木岛、女木岛、直岛）度过。决定写一篇专栏来记录我的第一次巡礼之旅。这是一场身体很累，但心灵却得到治愈的旅途。在这之中，我收获了许多意外的惊喜。</p><span id="more"></span><p>由于秋叶原Cafe&amp;Bar MENU咖啡吧的Summer Pockets联动（原先定于7月25日结束，现已延迟到9月1日结束，需要提前预约），在高松旅程结束之后，笔者一路北上经由： “高松 –轮渡–&gt; 直岛 –轮渡–&gt; 宇野 –JR+新干线–&gt; 大阪 –阪急–&gt; 京都 –JR（原定新干线，但当天新干线脱轨。不是万不得已请不要使用JR，会绕很远的路且费用更高）–&gt; 东京”的线路最终到达秋叶原（途中当然在各地都进行了游玩）。</p><p>此外，如果不打算前往京都，飞机也是一个很好的选择（京都没有任何的公共机场，<del>如果你长了螺旋桨，那么忽视这一段</del>）。如果没有鸟白岛巡礼以外的其他目的，那么全程几乎不需要用到JR或是新干线等轨道交通（在这种情况下，也没有必要购买交通卡）。</p><p>接下来，本文将会囊括以下内容：</p><!-- toc --><ul><li><a href="#part-1-%E4%BD%8F%E5%AE%BF%E7%9A%84%E9%80%89%E9%A1%B9">Part 1. 住宿的选项</a><ul><li><a href="#11-%E4%BD%8F%E5%9C%A8%E9%AB%98%E6%9D%BE%E6%88%96%E7%9B%B4%E5%B2%9B">1.1 住在高松或直岛</a></li><li><a href="#12-%E4%BD%8F%E5%9C%A8%E7%94%B7%E6%9C%A8%E5%B2%9B">1.2 住在男木岛</a></li><li><a href="#~~13-%E4%BD%8F%E5%9C%A8%E5%A5%B3%E6%9C%A8%E5%B2%9B~~"><del>1.3 住在女木岛</del></a></li></ul></li><li><a href="#part-2-%E4%B9%98%E5%9D%90%E6%B8%A1%E8%BD%AE%E7%9A%84%E7%BB%86%E8%8A%82">Part 2. 乘坐渡轮的细节</a><ul><li><a href="#21-%E9%9B%8C%E9%9B%84%E5%B2%9B%E8%88%AA%E7%BA%BF">2.1 雌雄岛航线</a></li><li><a href="#22-%E5%9B%9B%E5%9B%BD%E8%88%AA%E7%BA%BF">2.2 四国航线</a></li></ul></li><li><a href="#part-3-%E5%B7%A1%E7%A4%BC%E7%BA%BF%E8%B7%AF%E9%80%89%E6%8B%A9-%E5%B2%9B%E4%B8%8A%E7%9A%84%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F">Part 3. 巡礼线路选择、岛上的交通方式</a><ul><li><a href="#31-%E5%B7%A1%E7%A4%BC%E7%BA%BF%E8%B7%AF%E9%80%89%E6%8B%A9">3.1 巡礼线路选择</a></li><li><a href="#32-%E5%B2%9B%E4%B8%8A%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F">3.2 岛上交通方式</a></li></ul></li><li><a href="#part-4-%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%94%99%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A1%E7%A4%BC%E5%9C%B0%E7%82%B9">Part 4. 可能会错过的一些巡礼地点</a></li><li><a href="#part-5-%E5%AD%A3%E8%8A%82%E6%80%A7%E7%9A%84%E6%B4%BB%E5%8A%A82024%E5%B9%B4">Part 5. 季节性的活动（2024年）</a></li><li><a href="#part-6-%E5%B7%A1%E7%A4%BC%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7">Part 6. 巡礼可以选择的（软件）工具</a></li><li><a href="#part-7-%E5%9C%A8%E4%B8%8D%E4%BC%9A%E6%97%A5%E8%AF%AD%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">Part 7. 在不会日语的情况下，你可以做什么准备工作</a></li><li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li></ul><!-- tocstop --><p>本文中的内容并不一定是我的亲身经历，有一部分来自于问询其他巡礼者，仅在本文中将其记录，以备今后二周目巡礼时查看。如果这篇文章可以在未来的某个时间帮到某个人，那么就再好不过了。</p><h2><span id="part-1-住宿的选项">Part 1. 住宿的选项</span></h2><h3><span id="11-住在高松或直岛">1.1 住在高松或直岛</span></h3><p>高松或直岛本身旅游开发比较完善，因此你可以使用住宿软件十分轻松地订到这两处的酒店。如果你选择住在高松，那么请注意选择邻近高松港的酒店。假如你打算居住在游戏中的加藤家<br>（现实中位于直岛的石井商店），那么请提前大约4个月预订（消息来源：我在巡礼过程中，在石井商店遇到的一位中国SP粉丝）。</p><h3><span id="12-住在男木岛">1.2 住在男木岛</span></h3><p>如果你是一个紬厨，希望拍摄到黄昏或夜晚的灯塔；或者渴望体验游戏中羽依里、細、静久三人合宿的剧情，那么住宿在男木岛是一个不错的选择。<br>我并没有居住在男木岛，在巡礼回来之前也并不知晓男木岛住宿的方法，直到我询问了一位在男木岛过夜的中国SP粉丝，得到的答案如下：<br>岛上的旅店；<br>灯塔露营；<br>住丰爷家。<br>男木岛上的旅店目前暂且无法通过线上方式进行预订，需要线下自行沟通。而关于丰爷，我会在后文介绍。可以预料到，住在男木岛对于初次巡礼的人（尤其是社恐二次元）很难实行，也具有很大的不确定性。</p><h3><span id="13-住在女木岛"><del>1.3 住在女木岛</del></span></h3><p><del>嗯？谁会住在女木岛。</del></p><h2><span id="part-2-乘坐渡轮的细节">Part 2. 乘坐渡轮的细节</span></h2><p>前往男木岛和女木岛以及前往直岛的航线分别由：雌雄岛海运株式会社以及四国海运株式会社运营。二者的售票处位于相距几百米的不同地点，如果不知道具体位置，可以用日语或简单的英语询问工作人员。<br>对于各交通节点之间的可达关系，可以这样概括：高松港、男木岛和女木岛之间两两可达，高松港、宇野和直岛之间两两可达。</p><h3><span id="21-雌雄岛航线">2.1 雌雄岛航线</span></h3><p>由于男木岛和女木岛属于较冷门的旅游景点，每天的渡轮班次相对较少，而且每天很早就结束运营。其海运时间表如下图所示：<br><img src="/images/img.png" alt="images/img.png"><br>注意：发船时刻提前半个小时开始售票。从图中可以得知，如果选择在8月的前20天出行，则班次会相对较多，行程安排会更加自由。</p><h3><span id="22-四国航线">2.2 四国航线</span></h3><p>直岛往返的渡轮时刻表，如下图绿色部分所示（红色部分是岛上大巴、蓝色部分是直岛艺术馆的免费巴士):<br><img src="/images/img_1.png" alt="images/img_1.png"><br>上图为前往直岛、下图为离开直岛。</p><h2><span id="part-3-巡礼线路选择-岛上的交通方式">Part 3. 巡礼线路选择、岛上的交通方式</span></h2><h3><span id="31-巡礼线路选择">3.1 巡礼线路选择</span></h3><p>巡礼的顺序大概可以分成以下四类：</p><ul><li>男木女木、直岛；</li><li>直岛、男木女木；</li><li>女木男木、直岛；</li><li>直岛、女木男木。<br>首先，个人而言，我并不推荐将女木岛放在男木岛前面，尽管它距离高松港最近。我更加推荐以直岛或男木岛作为巡礼的起点。这两者之间，我会更加优先参观男木岛。对于初次巡礼的时间安排上，我的建议是两到三天。在直岛上完全可以待上两天时间，去享受夏季的阳光沙滩，或者参观一下岛上的艺术馆，感受“度过快乐暑假的秘诀”。如无特殊情况（例如准备在男木岛过夜），男木岛和女木岛一天足矣。<br>接下来，介绍一下优先男木岛的理由。这里就不得不提到之前所说的丰爷（twitter id:@nekopoketoyoji)。除去已经关门的直岛小卖铺，男木岛丰爷的ねこポケハウス（NekopokeHouse）是三座岛上Summer Pockets元素最为浓厚的地方。丰爷的家里接待过无数各地的SP厨和爱猫人士，你可以在那找到各种的SP周边、在来访者日记中留下自己的痕迹、和其他到访的SP厨交流心得、得到一些巡礼的指南、或者吸一会猫。丰爷是一个非常有意思的老爷爷，经常在推特上冲浪。<br>很遗憾的是，我前往男木岛的那天，丰爷刚好因为有事前往高松。我只在男木岛役馆（村公所）门口见到他一面，并且没认出来他，我的紬痛T引起了他的注意。后来，我们在推特上也有一些友好的交流。如果有能力的话，完全可以在巡礼之前先在推特上和丰爷提前联系，打个招呼。<br>丰爷的家就在男木岛下船后，右手边役所旁边的小道往里。（小道旁边有一片墓地，可以方便定位。没有恶意）<br><img src="/images/img_2.png" alt="images/img_2.png"><br><img src="/images/img_3.png" alt="images/img_3.png"><br><img src="/images/img_4.png" alt="images/img_4.png"><br><img src="/images/img_5.png" alt="images/img_5.png"></li></ul><h3><span id="32-岛上交通方式">3.2 岛上交通方式</span></h3><p>男木岛：有且只有步行，岛上道路坡度比较大，注意安全、记得补充体力。不要打扰到岛上的居民。 </p><p>女木岛：主要的巡礼地点是鬼岛大洞窟（鸥线），下船后购买巴士票直达。 </p><p>直岛：租借自行车（宫浦港旁边非常显眼的一家店铺）和公交车（100日元可以坐到岛上任意一站，可以在港口附近的售票处找一本直岛指南（如下图）<br>随手查阅路线和运营时间）。直岛上的交通是最方便的。（如果你重新玩一遍《夏日口袋》的话，会发现羽依里在上岛后不久即遭遇了公交车，这点十分还原）<br><img src="/images/img_6.png" alt="images/img_6.png"><br><img src="/images/img_7.png" alt="images/img_7.png"></p><h2><span id="part-4-可能会错过的一些巡礼地点">Part 4. 可能会错过的一些巡礼地点</span></h2><ul><li><p>游戏标题画面的出处在直岛地中艺术馆可以找到。不太好找，也不太像。是日本友人带我找到的。<br><img src="/images/img_8.png" alt="images/img_8.png"><br><img src="/images/img_9.png" alt="images/img_9.png"></p></li><li><p>白羽线吃可丽饼的cg在JR宇野站的停车场内（我当时并没有想起来去找）。<br><img src="/images/img_10.png" alt="images/img_10.png"></p></li><li><p>*途橘的原型在国营常陆海滨公园（从东京使用公共交通过去得4个小时以上），建议4、5月份花期的时候去。这里我还闹了一个乌龙，找到另一个名字很像的地方了，不过当时时间也很紧，就没再找下去了。如果打算去，建议在附近住宿并且安排一天的时间。图片来自谷歌地图。<br><img src="/images/img_11.png" alt="images/img_11.png"></p></li><li><p>直岛上，加藤家&#x2F;岛上食堂原型的石井商店营业时间是11点到下午2点，如要就餐记得妥善安排时间。</p></li><li><p>紬家的原型起云阁：4-2 Showacho, Atami, Shizuoka 413-0022日本。</p></li><li><p>鸥线海盗船停靠的地点原型龙宫窟：Touji, Shimoda, Shizuoka 415-0029日本。</p></li></ul><h2><span id="part-5-季节性的活动2024年">Part 5. 季节性的活动（2024年）</span></h2><p>Summer Pockets的许多活动的开始&#x2F;结束都与7月25日有关，游戏中这一天是羽依里上岛的日子。如果你提前几个月在做圣地巡礼的计划（例如希望以此作为毕业旅行），那么建议将旅行的时间定在这一天之后。更具体一点：这一天之后的周末、或是8月31日（紬的生日）。如果这样计划，碰上特别的活动的概率会最大化。例如，2024年7月25日之后的第一个周六，也就是7月27日，是Key社Summer Festival售卖SP周边开始的时间。同样是这一年，7月25日开始到8月31日结束，是男木岛灯台祭的期间，起的早一些有可能遇上意外之喜；如果更特殊一点，碰上了这一段时间的周末，那么也许就有机会进到灯塔内部参观。<br>当然也有例外，秋叶原的SP咖啡厅联动原定于7月25日截止（现在延迟到9月1日）。关于咖啡厅的预约（一般需要提供日本手机号），我通过本人经验和与其他人交流，总结出了以下方法：</p><ul><li>直接通过推特私信与工作人员联系。这种方法可能不太礼貌，但我成功了；</li><li>在手机号一栏填写中国驻日大使馆的电话号码；</li><li>使用咖啡厅的提问网站进行问询和预约，给清楚信息，说 明来意：<a href="https://menu-store.com/inquiry%EF%BC%9B">https://menu-store.com/inquiry；</a></li><li>“没必要这么麻烦，我有日本手机号”，那么直接预订即可。<br>联动咖啡厅的部分商品在秋叶原电波会馆的K-Books中被溢价倒卖，本人十分反感这种行为，因为我没在咖啡厅买到我想要的爱丽丝紬徽章。如果实在有想要单收的周边，可以去那看看。<br><img src="/images/img_12.png" alt="images/img_12.png"><br><img src="/images/img_13.png" alt="images/img_13.png"><br><img src="/images/img_14.png" alt="images/img_14.png"><br><img src="/images/img_15.png" alt="images/img_15.png"></li></ul><h2><span id="part-6-巡礼可以选择的软件工具">Part 6. 巡礼可以选择的（软件）工具</span></h2><p>首先，出国在外，我建议你不要使用华为手机。提前买好日本流量卡。带好充电宝，手机开着导航耗电飞快。<br>我所使用到的工具大致如下：</p><ul><li>Google地图：在日本比较好用的地图工具；</li><li>Google翻译：如果你在日语不好的情况下英语又不太好&#x2F;需要和不会使用英语的日本人交流，那么可以使用。提前熟悉功能（例如语音翻译等)，谷歌翻译的质量还是堪忧的；</li><li><a href="https://anitabi.cn/map">Anitabi动画巡礼网站</a>，可以比较方便地查找到巡礼地点的位置；</li><li>换乘案内：一个查询日本换乘路线的APP；</li><li>Agoda：酒店预订工具，使用别的软件替代也无所谓；</li><li>其他（待补充）</li></ul><h2><span id="part-7-在不会日语的情况下你可以做什么准备工作">Part 7. 在不会日语的情况下，你可以做什么准备工作</span></h2><p>在一个陌生的环境下，你的外表是最具冲击力的语言。如果你想第一时间让别人知道自己的目的，你可以选择穿一件喜欢角色的痛T（如果经济实力不够，淘宝定制的就足够了）。这是本人定制的痛T：<br><img src="/images/img_16.png" alt="images/img_16.png"><br>这是我的成果：<br><img src="/images/img_17.png" alt="images/img_17.png"><br>此外，提前在推特上关注丰爷等人的账号，熟悉外面的SP圈子，实时记录行程，可以帮助你更快地找到同好。<br>日本人<del>废话</del>说的不少，提前记一些常用日本礼貌用语，可以给他人留下一个好印象。他们做事的条条框框也比较多，可以提前熟悉，给自己一个比较好的体验。比如说：日本人走路会固定走某一侧，记得留意脚下的方向标志；在自动扶梯上记得空出右边的一条通路给赶时间的人行走；用完餐起身之前说一句「ご馳走樣でした。」表示对厨师的感谢；需要其他人帮忙的时候私密马赛一下绝对没有错。最重要的一点是，注意日本店铺的营业时间：许多（不是全部）店铺10点才开门（石井商店是11点），而晚上6点（比如说直岛上的餐厅）~8点就已经关门了；如果需要吃早餐，可以去随处可见的711、全家福超市（巡礼的体力消耗不小，建议不要忘记吃早餐）。</p><h2><span id="结语">结语</span></h2><p>祝愿读到这篇专栏的人能够从中获取一些有用的信息，可以在鸟白岛找到探求之物、找到自己、找到想做的事!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文搬运自本人的b站专栏。&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;今天是2024年7月26日。本人刚刚从日本返回中国，总计在日本停留了九天，其中前三天在高松（包括男木岛、女木岛、直岛）度过。决定写一篇专栏来记录我的第一次巡礼之旅。这是一场身体很累，但心灵却得到治愈的旅途。在这之中，我收获了许多意外的惊喜。&lt;/p&gt;</summary>
    
    
    
    <category term="anitabi" scheme="https://tsumugivolle77.github.io/categories/anitabi/"/>
    
    
    <category term="Summer Pockets" scheme="https://tsumugivolle77.github.io/tags/Summer-Pockets/"/>
    
    <category term="travel" scheme="https://tsumugivolle77.github.io/tags/travel/"/>
    
  </entry>
  
</feed>
